<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十大排序算法</title>
      <link href="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="排序算法介绍"><a href="#排序算法介绍" class="headerlink" title="排序算法介绍"></a>排序算法介绍</h3><ol><li><p>基本概要</p><blockquote><p>排序是将一组数据，依指定的顺序进行排列的过程。</p></blockquote></li><li><p>分类</p><blockquote><ul><li><p>内部排序:<br>指将需要处理的所有数据都加载到内部存储器中进行排序。</p></li><li><p>外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助外部存储进行<br>排序</p></li></ul></blockquote></li><li><p>常见种类</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327143815992.png" class=""><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327154141437.png" class=""></li></ol><h3 id="度量一个程序-算法-执行时间的两种方法"><a href="#度量一个程序-算法-执行时间的两种方法" class="headerlink" title="度量一个程序(算法)执行时间的两种方法"></a>度量一个程序(算法)执行时间的两种方法</h3><ol><li><p>事后统计法</p><blockquote><p>这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快</p></blockquote></li><li><p>事前估算法</p><blockquote><p>通过分析某个算法的时间复杂度来判断哪个算法更优</p></blockquote></li></ol><h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><ol><li><p>基本概念</p><blockquote><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)</p></blockquote></li><li><p>案例：计算1-100所有数字之和(两种算法的时间频度)</p><blockquote><p>第一个的意思是：你要计算1-100和，程序得运行101次（n=200则需要201次）</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19532021-ed3fa41113d7c0a2.png" class=""></blockquote></li></ol><h3 id="时间复杂度的忽略-常数项，低次项，系数"><a href="#时间复杂度的忽略-常数项，低次项，系数" class="headerlink" title="时间复杂度的忽略(常数项，低次项，系数)"></a>时间复杂度的忽略(常数项，低次项，系数)</h3><p>数据规模大,忽略才有用</p><ol><li><p>常数项</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19532021-398aba50a551bacc.png" class="" title="img"><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19532021-50908926891b727e.png" class="" title="img"><p><code>结论: </code></p><ul><li>2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略</li><li>3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略</li></ul></li><li><p>低次项</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327145634944.png" class="" title="image-20230327145634944"><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327145701848.png" class="" title="image-20230327145701848"><p><code>结论: </code></p><ul><li>2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 </li><li>3n+10n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20</li></ul></li><li><p>系数(既次方，平方，立方….)</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327145847885.png" class=""><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327145906295.png" class=""><p><code>结论:</code></p><ul><li> 随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。</li><li>而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键</li></ul></li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol><li><p>概述</p><blockquote><p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。<br> 人话：就是将 T(n)这个公式，通过上面的三个忽略法 变成 f(n)  ,再简写成 O(f(n))</p></blockquote></li><li><p>案例</p><blockquote><p>T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</p></blockquote></li><li><p>估算方式</p><blockquote><ul><li>用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  =&gt; T(n)=n²+7n+1</li><li>修改后的运行次数函数中，只保留最高阶项  T(n)=n²+7n+1 =&gt; T(n) = n²</li><li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li></ul></blockquote></li></ol><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><ul><li>常数阶O(1)</li><li>对数阶O(log2n)</li><li>线性阶O(n)</li><li>线性对数阶O(nlog2n)</li><li>平方阶O(n^2)</li><li>立方阶O(n^3)</li><li>k次方阶O(n^k)</li><li>指数阶O(2^n)</li></ul><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327150920851.png" class=""><p><code>说明：</code></p><ul><li>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低</li><li>从图中可见，我们应该尽可能避免使用指数阶的算法</li></ul><ol><li><p>常数阶O(1)</p><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327151109981.png" class=""><p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</p></li><li><p>对数阶O(log2n)</p><p><code>说明：</code>在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) .</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327152143016.png" class=""></li><li><p>线性阶O(n)</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327152217588.png" class=""><p><code>说明：</code>这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</p></li><li><p>线性对数阶O(nlogN)</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327152302631.png" class=""><p><code>说明：</code>线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</p></li><li><p>平方阶O(n²)</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230327152458104.png" class=""><p><code>说明：</code>平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n<em>n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m</em>n)</p></li><li><p>立方阶O(n³)、K次方阶O(n^k)</p><p><code>说明：</code>参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似</p></li></ol><h3 id="平均时间复杂度和最坏时间复杂度"><a href="#平均时间复杂度和最坏时间复杂度" class="headerlink" title="平均时间复杂度和最坏时间复杂度"></a>平均时间复杂度和最坏时间复杂度</h3><ol><li><p>概述</p><blockquote><ul><li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li><li> 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li><li> 平均时间复杂度和最坏时间复杂度是否一致，和算法有关</li></ul></blockquote></li><li><p>参考图</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19532021-ea8f1222ac77c489.png" class="" title="img"><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19532021-9c399721caf99c90.png" class="" title="img"><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19532021-9506d25bb0990a02.png" class="" title="img"></li></ol><h3 id="算法的空间复杂度简介"><a href="#算法的空间复杂度简介" class="headerlink" title="算法的空间复杂度简介"></a>算法的空间复杂度简介</h3><ol><li><p>基本介绍</p><blockquote><ul><li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况</li><li>在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.</li></ul></blockquote></li></ol><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><blockquote><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p></blockquote><ol><li><p><strong>算法描述</strong> </p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul></li><li><p><strong>动图演示</strong></p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/BubbleSort.gif" class="" title="img"></li><li><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序（Bubble Sort）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">8</span>,-<span class="number">1</span>,<span class="number">11</span>,-<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        optimizationBubbleSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generalBubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//临时便令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//最后一个数不用排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span> - i;j++)&#123;</span><br><span class="line">                <span class="comment">//比较两个数，如果前面的比后面的大则交换</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优化之后的排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">optimizationBubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//临时便令</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//表示是否进行过排序,</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//最后一个数不用排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span> - i;j++)&#123;</span><br><span class="line">                <span class="comment">//比较两个数，如果前面的比后面的大则交换</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;<span class="comment">//在一趟排序中，一次交换也没发生，说明已经有序了，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="comment">//重置flag，进行下次交换判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p><strong>最佳情况：T(n) = O(n)  最差情况：T(n) = O(n2)  平均情况：T(n) = O(n2)</strong></p></li></ol><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a><strong>选择排序（Selection Sort）</strong></h3><blockquote><p>表现<strong>最稳定的排序算法之一</strong>，因为<strong>无论什么数据进去都是O(n2)的时间复杂度</strong>，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote><ol><li><p>算法描述</p><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul></li><li><p>动图演示</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/SelectionSort.gif" class="" title="img"></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) <span class="comment">//找到最小的数</span></span><br><span class="line">                    minIndex = j; <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[minIndex];</span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p><strong>最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2)</strong></p></li></ol><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><blockquote><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p></blockquote><ol><li><p>算法描述</p><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></li><li><p>动图演示</p><p>1.图示</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/InsertionSort.gif" class="" title="img"><p>2.更直观点</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/InsertionSort2.gif" class="" title="img"></li></ol><p>​    </p><ol start="3"><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="type">int</span> current;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            current = array[i + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class="line">                array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p><strong>最佳情况：T(n) = O(n) 最坏情况：T(n) = O(n2) 平均情况：T(n) = O(n2)</strong></p></li></ol><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><br/><p><strong>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p><ol><li><p>算法描述</p><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，**{n/2,(n/2)/2…1}<strong>，称为</strong>增量序列**。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><br/><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul></li><li><p>动图演示</p><p>图示：</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/ShellSort.gif" class="" title="img"><p>过程演示：</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230328191603539.png" class=""></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] ShellSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="type">int</span> temp, gap = len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; len; i++) &#123;</span><br><span class="line">                temp = array[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; temp) &#123;</span><br><span class="line">                    array[preIndex + gap] = array[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                array[preIndex + gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            gap /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p><strong>最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog2n)</strong></p></li></ol><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p></blockquote><ol><li><p>算法描述</p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul></li><li><p>动图演示</p><p>图1:</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/MergeSort.gif" class=""><p>图2:</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/MergeSort2.gif" class=""></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] MergeSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> array.length / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="type">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">        <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序——将两段排序好的数组结合成一个排序数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] left, <span class="type">int</span>[] right) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[left.length + right.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; result.length; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= left.length)</span><br><span class="line">                result[index] = right[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length)</span><br><span class="line">                result[index] = left[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left[i] &gt; right[j])</span><br><span class="line">                result[index] = right[j++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result[index] = left[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p><strong>最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)</strong></p></li></ol><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><blockquote><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p></blockquote><ol><li><p>算法描述</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong>）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul></li><li><p>动图演示</p><p>欢快点的</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/QuickSort.gif" class=""><p>正经点的</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/QuickSort2.gif" class=""></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] QuickSort(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt;= array.length || start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> partition(array, start, end);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &gt; start)</span><br><span class="line">            QuickSort(array, start, smallIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &lt; end)</span><br><span class="line">            QuickSort(array, smallIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序算法——partition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> (<span class="type">int</span>) (start + Math.random() * (end - start + <span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> start - <span class="number">1</span>;</span><br><span class="line">        swap(array, pivot, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[end]) &#123;</span><br><span class="line">                smallIndex++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; smallIndex)</span><br><span class="line">                    swap(array, i, smallIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> smallIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组内两个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p><strong>最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn)</strong></p></li></ol><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><blockquote><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p></blockquote><ol><li><p>算法描述</p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul></li><li><p>动图演示</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/HeapSort.gif" class=""></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量，用于记录数组array的长度；</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] HeapSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        len = array.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">//1.构建一个最大堆</span></span><br><span class="line">        buildMaxHeap(array);</span><br><span class="line">        <span class="comment">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(array, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">            adjustHeap(array, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="comment">//从最后一个非叶子节点开始向上构造最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len/<span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) </span></span><br><span class="line">            adjustHeap(array, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整使之成为最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len &amp;&amp; array[i * <span class="number">2</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = i * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; array[i * <span class="number">2</span> + <span class="number">1</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">            swap(array, maxIndex, i);</span><br><span class="line">            adjustHeap(array, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p><strong>最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)</strong></p></li></ol><h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><blockquote><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p></blockquote><ol><li><p>算法描述</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul></li><li><p>动图演示</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/CountingSort.gif" class=""></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] CountingSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="type">int</span> bias, min = array[<span class="number">0</span>], max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">                max = array[i];</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; min)</span><br><span class="line">                min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        bias = <span class="number">0</span> - min;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            bucket[array[i] + bias]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; array.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                array[index] = i - bias;</span><br><span class="line">                bucket[i]--;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><p><strong>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)</strong></p></li></ol><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><blockquote><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p></blockquote><ol><li><p>算法描述</p><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><p><strong>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</strong></p></li><li><p>图片演示</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20230330092826718.png" class=""></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶排序</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">BucketSort</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="type">int</span> bucketSize)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="literal">null</span> || array.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array.get(<span class="number">0</span>), min = array.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到最大值最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array.get(i) &gt; max)</span><br><span class="line">                max = array.get(i);</span><br><span class="line">            <span class="keyword">if</span> (array.get(i) &lt; min)</span><br><span class="line">                min = array.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (max - min) / bucketSize + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketCount);</span><br><span class="line">        ArrayList&lt;Integer&gt; resultArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketSize == <span class="number">1</span>) &#123; <span class="comment">// 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)</span><br><span class="line">                    resultArr.add(bucketArr.get(i).get(j));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketCount == <span class="number">1</span>)</span><br><span class="line">                    bucketSize--;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; temp.size(); j++)</span><br><span class="line">                    resultArr.add(temp.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><p><strong>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2)</strong></p></li></ol><h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><blockquote><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p></blockquote><ol><li><p>算法描述</p><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul></li><li><p>动图演示</p><img src="/2018/03/30/MD-Java/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/RadixSort.gif" class=""></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] RadixSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">// 1.先算出最大数的位数；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">            maxDigit++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>, div = <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            bucketList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++, mod *= <span class="number">10</span>, div *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (array[j] % mod) / div;</span><br><span class="line">                bucketList.get(num).add(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                    array[index++] = bucketList.get(j).get(k);</span><br><span class="line">                bucketList.get(j).clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>算法分析</p><p><strong>最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k)</strong></p><p>基数排序有两种方法：</p><p>MSD 从高位开始进行排序 LSD 从低位开始进行排序</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FRP内网穿透部署</title>
      <link href="/2018/03/27/MD-Tool/FRP%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2018/03/27/MD-Tool/FRP%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器搭建（FRPS）"><a href="#服务器搭建（FRPS）" class="headerlink" title="服务器搭建（FRPS）"></a>服务器搭建（FRPS）</h2><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建存放目录</span></span><br><span class="line">sudo mkdir /etc/frp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建frps.ini文件</span></span><br><span class="line">sudo vim /etc/frp/frps.ini</span><br><span class="line">frps.ini内容如下：</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听端口</span></span><br><span class="line">bind_port = 7000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">面板端口</span></span><br><span class="line">dashboard_port = 7500</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录面板账号设置</span></span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin123</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置http及https协议下代理端口（非重要）</span></span><br><span class="line">vhost_http_port = 7080</span><br><span class="line">vhost_https_port = 7081</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">身份验证</span></span><br><span class="line">token = 12345678</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">服务器镜像：snowdreamtech/frps</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启：always</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">网络模式：host</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件映射：/etc/frp/frps.ini:/etc/frp/frps.ini</span></span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --restart=always --network host -d -v /etc/frp/frps.ini:/etc/frp/frps.ini --name frps snowdreamtech/frps</span><br></pre></td></tr></table></figure><h2 id="windows客户端配置（FRPC）"><a href="#windows客户端配置（FRPC）" class="headerlink" title="windows客户端配置（FRPC）"></a>windows客户端配置（FRPC）</h2><h3 id="获取frp"><a href="#获取frp" class="headerlink" title="获取frp"></a>获取frp</h3><p><a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p>选择windows相对应版本下载，例如：frp_0.44.0_windows_amd64</p><h3 id="frpc-ini配置文件"><a href="#frpc-ini配置文件" class="headerlink" title="frpc.ini配置文件"></a>frpc.ini配置文件</h3><p>在解压的frpc目录或安装的frpc目录下创建frpc.ini文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server_addr为FRPS服务器IP地址</span></span><br><span class="line">server_addr = 43.138.50.90</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server_port为服务端监听端口，bind_port</span></span><br><span class="line">server_port = 7000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">身份验证</span></span><br><span class="line">token = 12345678</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">远程桌面连接</span></span><br><span class="line">[rdp]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 7389</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[rdp] 为服务名称，下方此处设置为，访问frp服务段的7389端口时，等同于通过中转服务器访问127.0.0.1的3389端口。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">type</span> 为连接的类型，此处为tcp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">local_ip 为中转客户端实际访问的IP</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">local_port 为目标端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">remote_port 为远程端口</span></span><br></pre></td></tr></table></figure><h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><p>打开命令框，进入到安装目录启动，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd D:\App\frp\frp_0.44.0_windows_amd64</span><br><span class="line">cd </span><br><span class="line">d:</span><br><span class="line">frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure><h3 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h3><p>创建一个run.bat文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">Start &quot;&quot; &quot;D:\App\frp\frp_0.44.0_windows_amd64\frpc.exe&quot;</span><br></pre></td></tr></table></figure><p>将run.bat文件放入C:\Users\root\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup目录下，如下图所示：其中AppData为隐藏目录，就能够开机时自动执行脚本里的内容了。</p><h3 id="远程桌面连接"><a href="#远程桌面连接" class="headerlink" title="远程桌面连接"></a>远程桌面连接</h3><ol><li><p>mac连接</p><p>在mac上安装Microsoft Remote Desktop Beta</p><p>图例：</p><img src="/2018/03/27/MD-Tool/FRP%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20230529151040775.png" class="" title="image-20230529151040775"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea配置</title>
      <link href="/2018/03/26/MD-Tool/idea%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/03/26/MD-Tool/idea%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="idea-配置"><a href="#idea-配置" class="headerlink" title="idea 配置"></a>idea 配置</h1><h2 id="1-idea-激活"><a href="#1-idea-激活" class="headerlink" title="1. idea 激活"></a>1. idea 激活</h2><h2 id="2-插件安装"><a href="#2-插件安装" class="headerlink" title="2. 插件安装"></a>2. 插件安装</h2><h3 id="2-1-Lombok"><a href="#2-1-Lombok" class="headerlink" title="2.1 Lombok"></a>2.1 <strong>Lombok</strong></h3><blockquote><p>Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。</p></blockquote><h3 id="2-2-Codota"><a href="#2-2-Codota" class="headerlink" title="2.2 Codota"></a>2.2 <strong>Codota</strong></h3><blockquote><p>智能代码提示。</p></blockquote><h3 id="2-3-Rainbow-Brackets"><a href="#2-3-Rainbow-Brackets" class="headerlink" title="2.3 Rainbow Brackets"></a>2.3 <strong>Rainbow Brackets</strong></h3><blockquote><p>括号彩虹，可以将配对的括号采用同一个颜色显示。</p></blockquote><h3 id="2-4-Maven-Helper"><a href="#2-4-Maven-Helper" class="headerlink" title="2.4 Maven Helper"></a>2.4 <strong>Maven Helper</strong></h3><blockquote><p>解决依赖冲突。</p></blockquote><h3 id="2-5-Free-MyBatis-plugin"><a href="#2-5-Free-MyBatis-plugin" class="headerlink" title="2.5 Free MyBatis plugin"></a>2.5 <strong>Free MyBatis plugin</strong></h3><blockquote><p>mybatis 插件，让你的mybatis.xml像java代码一样编辑。我们开发中使用mybatis时时长需要通过mapper接口查找对应的xml中的sql语句，该插件方便了我们的操作。</p></blockquote><h3 id="2-6-String-Manipulation"><a href="#2-6-String-Manipulation" class="headerlink" title="2.6 String Manipulation"></a>2.6 <strong>String Manipulation</strong></h3><blockquote><p>强大的字符串转换工具。使用快捷键，Alt+m。</p></blockquote><h3 id="2-7-Alibaba-Java-Coding-Guidelines"><a href="#2-7-Alibaba-Java-Coding-Guidelines" class="headerlink" title="2.7 Alibaba Java Coding Guidelines"></a>2.7 <strong>Alibaba Java Coding Guidelines</strong></h3><blockquote><p>阿里巴巴代码规范检查插件。</p></blockquote><h3 id="2-8-Grep-console"><a href="#2-8-Grep-console" class="headerlink" title="2.8 Grep console"></a>2.8 <strong>Grep console</strong></h3><blockquote><p>自定义日志颜色，idea控制台可以彩色显示各种级别的log。</p></blockquote><h3 id="2-9-Git-Commit-Template"><a href="#2-9-Git-Commit-Template" class="headerlink" title="2.9 Git Commit Template"></a>2.9 <strong>Git Commit Template</strong></h3><blockquote><p>Git Commit提交规范。</p></blockquote><h3 id="2-10-GitToolBox"><a href="#2-10-GitToolBox" class="headerlink" title="2.10 GitToolBox"></a>2.10 <strong>GitToolBox</strong></h3><blockquote><p>查看每行代码是谁提交的</p></blockquote><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><h3 id="3-1-忽略文件"><a href="#3-1-忽略文件" class="headerlink" title="3.1 忽略文件"></a>3.1 忽略文件</h3><blockquote><p><strong>File-&gt;Settings-&gt;Editor-&gt;FileType-&gt;Ignore files ans folders</strong> 添加要屏蔽的文件 或文件夹;</p></blockquote><ul><li>*.gitignore</li><li>*.idea</li><li>*.iml</li></ul><h3 id="3-2-注释模板"><a href="#3-2-注释模板" class="headerlink" title="3.2  注释模板"></a>3.2  注释模板</h3><h3 id="3-3-自动导入依赖"><a href="#3-3-自动导入依赖" class="headerlink" title="3.3 自动导入依赖"></a>3.3 自动导入依赖</h3>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构与算法概述"><a href="#数据结构与算法概述" class="headerlink" title="数据结构与算法概述"></a>数据结构与算法概述</h2><h3 id="1、数据结构和算法的关系"><a href="#1、数据结构和算法的关系" class="headerlink" title="1、数据结构和算法的关系"></a>1、数据结构和算法的关系</h3><ul><li>数据 data 结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以 编写出更加漂亮,更加有效率的代码。 </li><li>要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决. </li><li><code>程序 = 数据结构 + 算法</code></li><li>数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。</li></ul><h3 id="2、线性结构与非线性结构"><a href="#2、线性结构与非线性结构" class="headerlink" title="2、线性结构与非线性结构"></a>2、线性结构与非线性结构</h3><p>​    &emsp;&emsp;数据结构包括：线性结构和非线性结构。</p><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><ul><li><p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系 </p></li><li><p>线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序 表，顺序表中的存储元素是连续的 </p></li><li><p>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地 址信息 </p></li><li><p>线性结构常见的有：数组、队列、链表和栈</p></li></ul><h4 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h4><p>&emsp;&emsp;非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p><hr><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h3><ul><li>队列是一个有序列表，可以用数组或是链表来实现。</li><li>遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li></ul><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210413170353329.png" class="" title="image-20210413170353329"> <h3 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h3><ol><li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图, 其中 maxSize 是该队列的最大容量。 </p></li><li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如队列介绍中图所示</p></li><li><p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析:</p><blockquote><ul><li><p>将尾指针往后移：rear+1 , 当 front == rear 【空】 </p></li><li><p>若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据</p></li></ul></blockquote></li><li><p><code>注意</code>:front并没有直接指向数据,而是数据前一位,所以当你要用front读取队列头时需要<code>front+1</code></p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//创建一个队列</span></span><br><span class="line">         <span class="type">ArrayQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">         <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">         <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="comment">//输出一个菜单</span></span><br><span class="line">         <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">             System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">             System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">             System.out.println(<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">             System.out.println(<span class="string">&quot;h(head):查看队列头的数据&quot;</span>);</span><br><span class="line">             key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接受一个字符</span></span><br><span class="line">             <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                     queue.showQueue();</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                     System.out.println(<span class="string">&quot;输入一个数字&quot;</span>);</span><br><span class="line">                     <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">//不用再new一个新得scanner</span></span><br><span class="line">                     queue.addQueue(value);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue.getQueue();</span><br><span class="line">                         System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                         System.out.println(e.getMessage());</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> queue.headQueue();</span><br><span class="line">                         System.out.printf(<span class="string">&quot;表头是%d\n&quot;</span>, head);</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                         System.out.println(e.getMessage());</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">default</span>:</span><br><span class="line">                     scanner.close();<span class="comment">//关闭不释放会有异常</span></span><br><span class="line">                     loop = <span class="literal">false</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> front; <span class="comment">//队列头</span></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span>[] arr; <span class="comment">//该数据用于存放数据,模拟队列</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//创建队列的构造器</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">         maxSize = arrMaxSize;</span><br><span class="line">         arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">         front = -<span class="number">1</span>;<span class="comment">//指向队列头部,分析出front是只想队列头的前一个位置</span></span><br><span class="line">         rear = -<span class="number">1</span>;<span class="comment">//指向队列尾部,只想队列尾部数据(即队列最后一个数据)</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//1. 判断队列是否满</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>; <span class="comment">//当队列为指向数组最后一位时就是队列满</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//2. 判断队列是否为空</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> rear == front; <span class="comment">//当队列头与尾部相等时,说明该队列没有值了</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//3. 添加数据到队列</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="comment">//判断队列是否满</span></span><br><span class="line">         <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;队列满,不能加入数据~~~~~~&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         rear++; <span class="comment">//让rear 往后移动一位</span></span><br><span class="line">         arr[rear] = n; <span class="comment">//以后移后的rear作为数组下标进行赋值</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4. 获取队列的数据,出队列</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//判断队列是否为空//抛出异常</span></span><br><span class="line">         <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">         front++; <span class="comment">//front后移 出队列</span></span><br><span class="line">         <span class="keyword">return</span> arr[front];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//5. 显示队列的所有数据</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//遍历</span></span><br><span class="line">         <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;队列空的 没有数据&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">             System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i, arr[i]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//显示队列的头数据,注意不是取出数据</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//判断</span></span><br><span class="line">         <span class="keyword">if</span> (isEmpty())  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空的,没有数据~~~~&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> arr[front + <span class="number">1</span>]; <span class="comment">//front并没有直接指向数据,而是数据前一位,所以需要+1</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>问题分析与优化方向</p><blockquote><ol><li>目前数组使用一次就不能用， 没有达到复用的效果.</li></ol><p> ​    <code>原因</code>:取出数据时是将列表头(<code>front++</code>)向后移动,导致队列前面的空间并没有被释放,如上图第三个队列示例图 </p><ol start="2"><li>将这个数组使用算法，改进成一个环形的队列 取模：%</li></ol></blockquote></li></ol><h3 id="数组模拟环形队列思路分析"><a href="#数组模拟环形队列思路分析" class="headerlink" title="数组模拟环形队列思路分析"></a>数组模拟环形队列思路分析</h3><ol><li><p>对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p></li><li><p>分析说明:</p><blockquote><ol><li><p>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize == front 满]</p></li><li><p>rear == front [空]</p></li></ol></blockquote></li><li><p>思路分析示例图</p></li></ol><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210413180656594.png" class="" title="image-20210413180656594"><ol start="4"><li><p>环形队列示例图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210413180729037.png" class="" title="image-20210413180729037"></li></ol><h3 id="个人对于环形队列的理解与总结"><a href="#个人对于环形队列的理解与总结" class="headerlink" title="个人对于环形队列的理解与总结"></a>个人对于环形队列的理解与总结</h3><ol><li><p><code>rear</code>初始化为0:因为当队列为空时,<code>rear</code>队列尾应是指向<code>-1</code>位置,因为整个队列是空的</p><blockquote><p>所以符合调整:rear指向队列的最后一个元素的后一个位置,可以留出一个空间作为约定(用来<code>判断是队空还是队满</code>)</p></blockquote></li><li><p><code>front</code>初始化为0:因为要指向队列第一个位置,所以为0</p></li><li><p>队列满条件:<code>(rear+1)%maxSize==front</code>–&gt;原理如上方环形队列示例图</p><blockquote><p>当<code>(rear+1)%maxSize==front</code>时,队列情况如环形队列示例图右边部分 –&gt;例: (4+1)%10==5</p></blockquote></li><li><p>队列为空<code>rear==front</code>:假使你队列曾经加到8个数据,所以你<code>rear==8</code>,但当你将队列一个一个取出时front发生如下变化:<code>front==0--&gt;front++*n--&gt;front==8</code>,所以当front==rear==8时,就可以判断队列为空</p></li><li><p>队列的有效数据个数:<code>(rear+maxSize-font)%maxSize</code> –&gt;</p><blockquote><p>提出疑惑:为什么要先加<code>maxSize</code>–&gt;可能出现队尾rear小于队首front的情况</p></blockquote></li></ol><p>  &emsp;&emsp;通过这个环形队列图(里面数字是<code>数组下标</code>不是数据)你应该可以很容易理解:假使队列长8、队尾在2的位置、队首在6的位置</p><p>&emsp;&emsp;解决:如图所示</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210413184647572.png" class="" title="image-20210413184647572"><blockquote><p>再次提出疑惑:我看图上<code>6~2</code>,甚至还用手指去数,明明就是五个数据啊!为什么还能算成<code>4</code>?</p></blockquote><p>​    解:注意<code>rear</code>的定义:rear指向队列的最后一个元素的后一个位置,所以这时候最后一个队列数据是在<code>1</code>的位置,所以<code>6~1</code>是4位</p><h3 id="环形队列代码实现"><a href="#环形队列代码实现" class="headerlink" title="环形队列代码实现"></a>环形队列代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> com.queue;</span><br><span class="line">&gt;<span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayQueueDemo</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//创建一个环形队列</span></span><br><span class="line">  System.out.println(<span class="string">&quot;创建一个环形队列&quot;</span>);</span><br><span class="line">  <span class="type">CircleArrayQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//输出一个菜单</span></span><br><span class="line">  <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">   .....<span class="comment">//同上面队列代码调用,省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">CircleArrayQueue</span> &#123;</span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span> front; <span class="comment">//队列头</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span> rear; <span class="comment">//队列尾部</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//该数据用于存放数据,模拟队列</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//创建队列的构造器</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">CircleArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">  <span class="comment">//注意:如果要能存3个有效数据,arrMaxSize就要为`4`,因为预留了一个位置,所以需要传入的数字要+1</span></span><br><span class="line">  maxSize = arrMaxSize + <span class="number">1</span>;</span><br><span class="line">  arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1. 此处front含义做出调整:front指向队列的第一个元素,也就是说arr[front]就是队列的第一个元素,front的初始值为0*</span></span><br><span class="line"><span class="comment">       * 2.此处rear含义做出调整:rear指向队列的最后一个元素的后一个位置,因为希望空出一个空间作为约定(判断栈满栈空),rear的初始值为0</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      front = rear = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 判断队列是否满</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//此时队满条件发生变化,因为rear预留了一个位置</span></span><br><span class="line">      <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 判断队列是否为空</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> front == rear;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 3.获取队列的有效数量</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> int  此函数结果用来在 遍历队列数组时防止下标越界</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4. 添加数据到队列</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      <span class="comment">//判断是否队满</span></span><br><span class="line">      <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;队列满,不能加入数据~~~~~&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[rear] = n;<span class="comment">//这里需要先赋值再将rear+1,因为rear指向最后一个有效数据</span></span><br><span class="line">      <span class="comment">//让rear后移一位,但是需要注意`%`,因为栈尾可以回到下标为`0`处,原因看我画的图</span></span><br><span class="line">      rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5. 获取队列数据 出队列(类似删除数组第一位)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//判断队列是否为空,抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这里需要先将`front`的值保存下来(或者直接保存arr[front],再去return),因为front此时对应的是第一个有效数据,如果＋1后再返回,将指向错误的有效数据</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">thisFront</span> <span class="operator">=</span> front;</span><br><span class="line">      <span class="comment">//front后移,原因与注意点同rear</span></span><br><span class="line">      front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">      <span class="keyword">return</span> arr[thisFront];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//6. 显示所有队列的数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//先判断是否为空</span></span><br><span class="line">      <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;队列为空,没有数据&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1.首先front指向队列第一位,所以要从front开始遍历</span></span><br><span class="line"><span class="comment">       * 2.结束</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; front + getSize(); i++) &#123;</span><br><span class="line">          System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//7. 显示队列的头数据,注意不是取出数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//判断是否为空</span></span><br><span class="line">      <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空的,没有数据~~~~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//front是直接指向队列第一位的,所以这里可以直接返回</span></span><br><span class="line">      <span class="keyword">return</span> arr[front];</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表-Linked-List-介绍"><a href="#链表-Linked-List-介绍" class="headerlink" title="链表(Linked List)介绍"></a>链表(Linked List)介绍</h3><ol><li><p>链表是以节点的方式来存储,是链式存储 </p></li><li><p>每一个结点包含 data 域、next 域。其中 next 域存放的是下一个结点的地址(双向链表还有一个<code>prev</code>)</p></li><li><p>如图：发现链表的各个节点不一定是连续存储. </p></li></ol><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323164336413.png" class="" title="image-20230323164336413"><ol start="4"><li><p>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</p></li><li><p>单链表(带头结点) 逻辑结构示意图如下</p></li></ol><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323164423403.png" class="" title="image-20230323164423403"><ol start="6"><li><p>代码描述节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age;<span class="comment">// 本结点的信息</span></span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> ListNode next; <span class="comment">// 下一个结点的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="单链表的应用实例"><a href="#单链表的应用实例" class="headerlink" title="单链表的应用实例"></a>单链表的应用实例</h3><p>&emsp;&emsp;使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作</p><h4 id="添加方法一-在添加英雄时，直接添加到链表的尾部"><a href="#添加方法一-在添加英雄时，直接添加到链表的尾部" class="headerlink" title="添加方法一:在添加英雄时，直接添加到链表的尾部"></a>添加方法一:在添加英雄时，直接添加到链表的尾部</h4><ol><li>思路分析示意图:</li></ol><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323164744040.png" class="" title="image-20230323164744040"><ol start="2"><li><p>演示最基础的链表插入:<code>插入到链表的最后面</code>,不考虑顺序</p><ul><li>首先我们需要创建一个头结点，该结点的作用就是表示单链表的头，如果没有头结点，我们是无法知道链表的首个结点是谁、在哪；</li><li>单链表是单向的，所以我们需要从头结点开始遍历整个链表直到末尾，然后增加结点到链表的末尾；</li><li>需要注意的是，头结点是万万不能乱动的，所以我们最好将头结点复制到一个临时结点变量中，对临时变量进行遍历。</li></ul></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.firstadd;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示最基础的链表插入,插入到链表的最后面,不考虑顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstAdd</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先创建节点对象,一个节点就是一个节点英雄</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="comment">//创建链表对象</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">        <span class="comment">//不按顺序添加</span></span><br><span class="line">        singleLinkedList.add(hero1);</span><br><span class="line">        singleLinkedList.add(hero4);</span><br><span class="line">        singleLinkedList.add(hero2);</span><br><span class="line">        singleLinkedList.add(hero3);</span><br><span class="line">        <span class="comment">//调用打印</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一、定义一个HeroNode,每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了显示方法,我们重新toString;里不打印next,是因为如果这样打印的话,会将整个链表全部打印出来</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二、定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//1. 先初始化一个头节点,头节点不要动,不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 返回头节点,get方法</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 添加节点到单链表后</span></span><br><span class="line"><span class="comment">     * 思路:不考虑编号顺序,直接插入到链表最后</span></span><br><span class="line"><span class="comment">     * 1)找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2)将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表,找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后:当next值为空,就是最后一位</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果没有找到最后,就将temp向后移动,不然就原地踏步死循环了</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环的时候,temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后这个节点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 显示链表[遍历]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="添加方法二-根据排名将英雄插入到指定位置"><a href="#添加方法二-根据排名将英雄插入到指定位置" class="headerlink" title="添加方法二:根据排名将英雄插入到指定位置"></a>添加方法二:根据排名将英雄插入到指定位置</h4><ol><li><p>如果有这个排名(即no重复)，则添加失败，并给出提示</p></li><li><p>思路分析示意图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323165149509.png" class="" title="image-20230323165149509"></li><li><p>代码中实例场景示例图:</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323165226641.png" class="" title="image-20230323165226641"></li><li><p>思路分析:</p><ul><li>首先还是要创建一个头结点，然后拷贝一个头结点作为辅助变量，使用辅助变量来遍历整个链表；</li><li>如果出现某个结点（假设是 A 结点）的下一个结点（假设是 B 结点）的编号大于待插入结点的情况，那么就首先将 B 结点记录在待插入的结点中，然后再将这个待插入结点插入到 A 结点之后；</li><li>如果遍历到了链表末尾还没找到编号更大的，就直接插入到末尾即可。</li></ul></li><li><p>代码实现:(只是将第一方法代码示例中的<code>add()</code>替换未<code>addByOrder</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">    <span class="comment">/*因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line"><span class="comment">       因为单链表,所以我们找的temp 必须为于添加位置的前一个节点,否则插入不了*/</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//flag标识添加的编号是否存在,默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明temp已经在链表的最后,就在链表插入(此时temp已经在链表尾部了)</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) <span class="keyword">break</span>;<span class="comment">//说明位置已经找到,就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode编号已经存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//temp后移,直到找到符合上面条件为止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了,不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将heroNode插入到链表的temp后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------- main()中调用  ------------------------</span><br><span class="line"> singleLinkedList.addByOrder(hero2);</span><br><span class="line"> singleLinkedList.addByOrder(hero4);</span><br><span class="line"> singleLinkedList.addByOrder(hero4);</span><br></pre></td></tr></table></figure></li></ol><h4 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h4><ol><li><p>思路(1) 先找到该节点，通过遍历，(2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname</p><ul><li>首先还是要创建一个头结点，然后拷贝一个头结点作为辅助变量，使用辅助变量来遍历整个链表；</li><li>遍历过程中，比对每个结点的编号与要更新的结点的编号是否一致，如果一致则说明找到了要更新的结点。接着将找到的结点中的数据替换成要更新的数据即可；</li><li>如果遍历结束还没找到对应编号的结点，说明链表中不存在这个结点；</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 修改节点信息,根据no编号来修改,即no编号不能改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">        <span class="comment">//定义一个辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//找到需要修改的节点,根据no编号</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">//表示当前到链表尾端</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;<span class="comment">//表示找到该节点了</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;<span class="comment">//根据flag可以判断是否找到要修改的节点</span></span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;没有找到编号%d的阶段,不能进行修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">    &#125;</span><br><span class="line">----------------- main()调用测试 ----------------------------------------</span><br><span class="line">  <span class="comment">//测试修改节点的代码</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟~~&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试修改后的&quot;</span>);</span><br><span class="line">        singleLinkedList.list();  </span><br></pre></td></tr></table></figure></li></ol><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><ol><li><p>思路分析:</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323165525723.png" class="" title="image-20230323165525723"><ul><li>其实就是方法二中<code>实例场景示例图</code>的逆推</li><li>首先还是要创建一个头结点，然后拷贝一个头结点作为辅助变量，使用辅助变量来遍历整个链表；</li><li>如果 遍历到某个结点的编号与要查找的给定的编号相同，那么就找到了结点；</li><li>如果遍历结束还没找到，说明该编号不在链表的结点中。</li></ul></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//6. 删除节点1.head不能动,所以需要一个temp辅助节点找到待删除节点前的一个节点</span></span><br><span class="line">    <span class="comment">//         2.我们比较时,时temp.next.no和待删除节点的no比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明到了链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//表示找到了待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) temp.next=temp.next.next; <span class="comment">//如果找到,进行删除</span></span><br><span class="line">        <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>,no);</span><br><span class="line">    &#125;</span><br><span class="line">----------------- main()调用 ------------------------------</span><br><span class="line">   <span class="comment">//删除一个节点</span></span><br><span class="line">    singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">    singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">    singleLinkedList.list();</span><br></pre></td></tr></table></figure></li></ol><h4 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h4><ol><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.secondadd;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="comment">//先创建节点对象,一个节点就是一个节点英雄</span></span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">   <span class="comment">//创建链表对象</span></span><br><span class="line">   <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">   <span class="comment">//1. 不按顺序添加:方法一</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero4);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero3);</span></span><br><span class="line">   <span class="comment">//2. 添加方法二</span></span><br><span class="line">   singleLinkedList.addByOrder(hero1);</span><br><span class="line">   singleLinkedList.addByOrder(hero3);</span><br><span class="line">   singleLinkedList.addByOrder(hero2);</span><br><span class="line">   singleLinkedList.addByOrder(hero4);</span><br><span class="line">   singleLinkedList.addByOrder(hero4);</span><br><span class="line">   <span class="comment">//调用打印</span></span><br><span class="line">   singleLinkedList.list();</span><br><span class="line">   <span class="comment">//3. 测试修改节点的代码</span></span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟~~&quot;</span>);</span><br><span class="line">   singleLinkedList.update(newHeroNode);</span><br><span class="line">   System.out.println(<span class="string">&quot;测试修改后的&quot;</span>);</span><br><span class="line">   singleLinkedList.list();</span><br><span class="line">   <span class="comment">//4. 删除一个节点</span></span><br><span class="line">   singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">   singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">   singleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**-------下面 `面试题部分`方法可以放在这个地方进行运行 编写的是静态方法----------------*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> K)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedHead</span><span class="params">(HeroNode head)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span> &#123;&#125;</span><br><span class="line"><span class="comment">/**-------下面 `面试题部分`方法可以放在这个地方进行运行----------------*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一、定义一个HeroNode,每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.no = no;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line">   <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了显示方法,我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二、定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line"><span class="comment">//1. 先初始化一个头节点,头节点不要动,不存放具体的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 返回头节点,get方法  这个方法是配合下面面试题时使用,使外面也能获得私有变量</span></span><br><span class="line"><span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3. 添加节点到单链表后-----------------弃用的,用来对比`addByOrder()`</span></span><br><span class="line"><span class="comment">    * 思路:不考虑编号顺序,直接插入到链表最后</span></span><br><span class="line"><span class="comment">    * 1)找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">    * 2)将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">       <span class="comment">//因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="comment">//遍历链表,找到最后</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">//找到链表的最后:当next值为空,就是最后一位</span></span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//如果没有找到最后,就将temp向后移动,不然就原地踏步死循环了</span></span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当退出while循环的时候,temp就指向了链表的最后</span></span><br><span class="line">       <span class="comment">//将最后这个节点的next指向新的节点</span></span><br><span class="line">       temp.next = heroNode;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4. 添加节点到单链表后,按no排序</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">   <span class="comment">/*因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line"><span class="comment">      因为单链表,所以我们找的temp 必须为于添加位置的前一个节点,否则插入不了*/</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//flag标识添加的编号是否存在,默认为false</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明temp已经在链表的最后,就在链表插入(此时temp已经在链表尾部了)</span></span><br><span class="line">           <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) <span class="keyword">break</span>;<span class="comment">//说明位置已经找到,就在temp的后面插入</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode编号已经存在</span></span><br><span class="line">               flag = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;<span class="comment">//temp后移,直到找到符合上面条件为止</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了,不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//将heroNode插入到链表的temp后面</span></span><br><span class="line">           heroNode.next = temp.next;</span><br><span class="line">           temp.next = heroNode;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5. 修改节点信息,根据no编号来修改,即no编号不能改</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ;</span><br><span class="line">       <span class="comment">//定义一个辅助变量</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">//找到需要修改的节点,根据no编号</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">//表示当前到链表尾端</span></span><br><span class="line">           <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;<span class="comment">//表示找到该节点了</span></span><br><span class="line">               flag = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) &#123;<span class="comment">//根据flag可以判断是否找到要修改的节点</span></span><br><span class="line">           temp.name = newHeroNode.name;</span><br><span class="line">           temp.nickname = newHeroNode.nickname;</span><br><span class="line">       &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;没有找到编号%d的阶段,不能进行修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//6. 删除节点1.head不能动,所以需要一个temp辅助节点找到待删除节点前的一个节点</span></span><br><span class="line">   <span class="comment">//         2.我们比较时,时temp.next.no和待删除节点的no比较</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line"><span class="comment">//        if (head.next == null) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;链表为空&quot;);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;此处可以不加,与下面代码功能重复</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明到了链表的最后</span></span><br><span class="line">           <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">               <span class="comment">//表示找到了待删除节点的前一个节点temp</span></span><br><span class="line">               flag = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) temp.next = temp.next.next; <span class="comment">//如果找到,进行删除</span></span><br><span class="line">       <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>, no);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//7. 显示链表[遍历]</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//判断链表是否为空</span></span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//输出节点信息</span></span><br><span class="line">           System.out.println(temp);</span><br><span class="line">           <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="单链表-面试题"><a href="#单链表-面试题" class="headerlink" title="单链表 面试题"></a>单链表 面试题</h3><blockquote><p>单链表的常见面试题有如下:</p><p>1)求单链表中有效节点的个数</p><p>2)查找单链表中的倒数第k个结点 【新浪面试题】</p><p>3)单链表的反转【腾讯面试题，有点难度】</p><p>4)从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】</p><p>5)合并两个有序的单链表，合并之后的链表依然有序【课后练习.】</p><p>以下例子将在<code>2</code>部分的全部代码中实现,在上面代码中<code>已经预留位置</code></p></blockquote><h4 id="求单链表中有效节点的个数"><a href="#求单链表中有效节点的个数" class="headerlink" title="求单链表中有效节点的个数"></a>求单链表中有效节点的个数</h4><ol><li><p>就是直接遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 求单链表中有效节点的个数</span></span><br><span class="line"><span class="comment">    * 方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//空链表</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//声明一个累加器</span></span><br><span class="line">       <span class="comment">//定义一个辅助的变量,这里我们没有统计头节点(--&gt;head.next)</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;<span class="comment">//当当前节点 为空时退出累计遍历</span></span><br><span class="line">           length++;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> length;</span><br><span class="line">   &#125;;</span><br><span class="line">-----------------main()调用  ---------------------------</span><br><span class="line">System.out.println(<span class="string">&quot;有效的节点个数=&quot;</span> + getLength(singleLinkedList.getHead()));<span class="comment">//2</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="查找单链表中的倒数第k个结点-【新浪面试题】"><a href="#查找单链表中的倒数第k个结点-【新浪面试题】" class="headerlink" title="查找单链表中的倒数第k个结点 【新浪面试题】"></a>查找单链表中的倒数第k个结点 【新浪面试题】</h4><ol><li><p>思路分析:</p><blockquote><ul><li>1)编写一个方法，接收head节点，同时接收一个K</li><li>2)K表示是倒数第K个节点</li><li>3)先把链表从头到尾遍历，得到链表的总的长度 getLength</li><li>4)得到size 后，我们从链表的第一个开始遍历 (size-K)个，就可以得到</li><li>5)如果找到了，则返回该节点，否则返回null</li></ul></blockquote></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**2.查找单链表中的倒数第k个结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 要进行查找的单向链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> K 传入倒数第几位 数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该位置的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//空链表,无法找到</span></span><br><span class="line">        <span class="comment">//1. 获得链表的长度(总个数)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">        <span class="comment">//2. 做一个K的校验,明显K不能为负数以及大于总长度</span></span><br><span class="line">        <span class="keyword">if</span> (K &lt;= <span class="number">0</span> || K &gt; size) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//3. 定义给辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//4. 遍历 倒数第K个节点 就是`size-K`的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (size - K); i++) &#123;</span><br><span class="line">            cur = cur.next; <span class="comment">//cur后移到符合条件的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">-----------------main()调用  ---------------------------</span><br><span class="line"> <span class="comment">//测试一下看看是否得到了倒数第K个节点</span></span><br><span class="line"> <span class="type">HeroNode</span> <span class="variable">res</span> <span class="operator">=</span> findLastIndexNode(singleLinkedList.getHead(), <span class="number">2</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br></pre></td></tr></table></figure></li></ol><h4 id="单链表的反转【腾讯面试题，有点难度】"><a href="#单链表的反转【腾讯面试题，有点难度】" class="headerlink" title="单链表的反转【腾讯面试题，有点难度】"></a>单链表的反转【腾讯面试题，有点难度】</h4><ol><li><p>解决这个问题的核心就是<code>头插法</code></p><ul><li>首先创建一个临时头结点用于记录反转过程中的链表；</li><li>遍历单链表，每遍历到一个有效结点，就让该有效结点指向临时头结点指向的结点；</li><li>临时头结点再指向该有效结点，</li><li>原单链表遍历结束之后，再让原头结点指向临时头结点指向的结点。</li></ul></li><li><p>图片示例</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%B4%E6%8F%92%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" class="" title="image-20230324085311268"></li><li><p>具体举例图解</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324085340478.png" class="" title="image-20230324085340478"></li><li><p>代码实现</p><ul><li><p>实现方法一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 3.单链表的反转【腾讯面试题，有点难度】</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> head 传入需要进行反转的单链表</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedHead</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">           <span class="comment">//1. 当链表为空或者只有一个节点时候,直接返回,无需反转</span></span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">           <span class="comment">//2. 定义一个辅助的指针遍历,帮助我们遍历原来的链表</span></span><br><span class="line">           <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">           <span class="comment">//3. 定义一个next,辅助变量,来指向当前节点[cur]的下一个节点,用来进行位置互换</span></span><br><span class="line">           <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//4. 初始化一个新的头节点,用来暂时存放反转链表</span></span><br><span class="line">           <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">           <span class="comment">//5. 遍历原来的链表,每遍历一个节点,就将其取出,并放在新的链表reverseHead的最前端</span></span><br><span class="line">           <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;<span class="comment">//当当前节点 为空时退出累计遍历</span></span><br><span class="line">               next = cur.next; <span class="comment">//先暂时保存当前节点的下一个节点,后面换完位置后需要复原cur的下一位,否则无法遍历</span></span><br><span class="line">               cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">               reverseHead.next = cur;<span class="comment">//将cur链接到新的链表上</span></span><br><span class="line">               cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//遍历结束,将head.next指向reverseHead.next 接管链表,实现单链表的反转</span></span><br><span class="line">           head.next = reverseHead.next;</span><br><span class="line">       &#125;</span><br><span class="line">   -----------------main()调用  ---------------------------</span><br><span class="line">      <span class="comment">//7. 测试一下单链表的反转功能</span></span><br><span class="line">   System.out.println(<span class="string">&quot;原来链表的情况~~&quot;</span>);</span><br><span class="line">   singleLinkedList.list();</span><br><span class="line">   System.out.println(<span class="string">&quot;反转单链表~~&quot;</span>);</span><br><span class="line">   reverseLinkedHead(singleLinkedList.getHead());</span><br><span class="line">   singleLinkedList.list();</span><br></pre></td></tr></table></figure></li><li><p>实现方法二(只是写法改变,但代码显得更容易理解)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SingleLinkedList <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">SingleLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">    <span class="comment">// 遍历待反转的链表，将结点依次添加到新链表</span></span><br><span class="line">   <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (tmp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        linkedList.addFirst(tmp.next.item);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addFirst</span><span class="params">(Integer item)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(item, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// tmp 指向头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    newNode.next = tmp.next;</span><br><span class="line">    tmp.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="从尾到头打印单链表"><a href="#从尾到头打印单链表" class="headerlink" title="从尾到头打印单链表"></a>从尾到头打印单链表</h4><ol><li><p>【百度面试题，要求方式1：反向遍历(上一个问题解决) 。 方式2：Stack栈   方法3: 递归】</p></li><li><p><code>栈方法</code></p></li><li><p>思路分析图解</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324085606977.png" class="" title="image-20230324085606977"></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 4. 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> head 要传入的链表头</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">//空链表 不能打印</span></span><br><span class="line">     <span class="comment">//创建一个栈,将各个节点压入栈</span></span><br><span class="line">     Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt;();</span><br><span class="line">     <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">     <span class="comment">//将链表所有节点压入栈</span></span><br><span class="line">     <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">         stack.push(cur);</span><br><span class="line">         cur = cur.next;<span class="comment">//cur后移,这样就可以压入下一个节点</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//将栈中节点取出打印.利用其先进后出特点,实现逆序da&#x27;yin</span></span><br><span class="line">     <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         System.out.println(stack.pop());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> -----------------main()调用  ---------------------------</span><br><span class="line"><span class="comment">//8.测试逆序打印单链表, 没有改变链表的结构~~</span></span><br><span class="line">System.out.println(<span class="string">&quot;测试逆序打印单链表, 没有改变链表的结构~~&quot;</span>);</span><br><span class="line">reversePrint(singleLinkedList.getHead());</span><br></pre></td></tr></table></figure></li><li><p><code>递归方式</code></p></li><li><p>图例</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0%E7%A4%BA%E4%BE%8B%E5%9B%BE.gif" class="" title="image-20230324085746357"></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归打印结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> [node] 链表的第一个结点，即 head.next</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printReverse_3</span><span class="params">(HeroNode node)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里一定要先递归调用再打印</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        printReverse_3(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="合并两个有序的单链表，合并之后的链表依然有序"><a href="#合并两个有序的单链表，合并之后的链表依然有序" class="headerlink" title="合并两个有序的单链表，合并之后的链表依然有序"></a>合并两个有序的单链表，合并之后的链表依然有序</h4><ol><li><p>思路解析</p><ul><li><p>如果传入的节点1为空了(即已经递归到链表尾或者是空链表),返回节点2,反之亦然(同时return会结束该递归函数(但是递归函数结束后接着return,所以整个递归函数将会停止)并返回)。</p></li><li><p>判断no是否重复,如果重复就重新递归传入链表下一级<code>head2.next</code>,不重复就传入<code>head2</code></p></li><li><p>递归其实都是在进行对于<code>head.next</code>的赋值,直到传入节点为空(符合前面两个判断条件),开始向外<code>return</code>,此时逐层给<code>head.next</code>赋值,最后会返回到最外层函数返回值处,就是合并后的链表</p></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 合并两个单链表静态函数</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> head1 传入第一个链表头节点</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> head2 传入第二个链表头节点</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 返回合并后的链表</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">mergeLinkedList</span><span class="params">(HeroNode head1, HeroNode head2)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (head1 == <span class="literal">null</span>) <span class="keyword">return</span> head2; <span class="comment">//此处是递归,不能按head.next==null进行判断,否则会造成数据丢失</span></span><br><span class="line">          <span class="keyword">if</span> (head2 == <span class="literal">null</span>)  <span class="keyword">return</span> head1;     </span><br><span class="line">          <span class="keyword">if</span> (head1.no &lt;= head2.no) &#123;</span><br><span class="line">              <span class="comment">//如果不加这个判断,如果两者的no相同,将会导致出现重复的数据(如两个),判断后进入递归</span></span><br><span class="line">              <span class="comment">//打印代码 System.out.println(&quot;head:&quot;+head+&quot;,head.next:&quot;+head.next);</span></span><br><span class="line">              <span class="comment">//打印结果 headHeroNode:[no=0,name=,nickname=],head.nextHeroNode:[no=0,name=,nickname=]</span></span><br><span class="line">              head1.next = (head2.no != head1.no) ? mergeLinkedList(head1.next, head2)</span><br><span class="line">                  : mergeLinkedList(head1.next, head2.next);</span><br><span class="line">  <span class="comment">//            head1.next= mergeLinkedList(head1.next, head2);  犯下的错误,导致数据重复</span></span><br><span class="line">              <span class="keyword">return</span> head1;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              head2.next = mergeLinkedList(head1, head2.next);</span><br><span class="line">              <span class="keyword">return</span> head2;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 遍历打印静态链表</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> head 传入打印的链表头节点</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticList</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">          <span class="comment">//判断链表是否为空</span></span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">          <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">          System.out.println(<span class="string">&quot;head&quot;</span> + head + <span class="string">&quot;,head.next&quot;</span> + head.next);</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">//输出节点信息</span></span><br><span class="line">              System.out.println(temp);</span><br><span class="line">              <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  -------------------  main()调用 --------------------------------</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;努力学习的汪&quot;</span>, <span class="string">&quot;好学生&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">7</span>, <span class="string">&quot;离婚且带娃&quot;</span>, <span class="string">&quot;不是我&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;你听我狡辩&quot;</span>, <span class="string">&quot;口头禅&quot;</span>);</span><br><span class="line">        <span class="comment">//创建链表对象</span></span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">    <span class="comment">//2. 添加方法</span></span><br><span class="line">    singleLinkedList.addByOrder(hero1);</span><br><span class="line">    singleLinkedList.addByOrder(hero3);</span><br><span class="line">    singleLinkedList.addByOrder(hero4);</span><br><span class="line">    singleLinkedList.addByOrder(hero7);</span><br><span class="line">    singleLinkedList.list();</span><br><span class="line">    System.out.println(<span class="string">&quot;两个链表分界线&quot;</span>);</span><br><span class="line">    <span class="comment">//-----------课后作业:第二个链表-----------------------</span></span><br><span class="line">    singleLinkedList1.addByOrder(hero2);</span><br><span class="line">    singleLinkedList1.addByOrder(hero5);</span><br><span class="line">    singleLinkedList1.addByOrder(hero6);</span><br><span class="line">    singleLinkedList1.addByOrder(hero8);</span><br><span class="line">    singleLinkedList1.list();</span><br><span class="line">    System.out.println(<span class="string">&quot;合并两个链表&quot;</span>);</span><br><span class="line">    staticList(mergeLinkedList(singleLinkedList.getHead(), singleLinkedList1.getHead()));</span><br></pre></td></tr></table></figure></li></ol><h3 id="双向链表与其实例"><a href="#双向链表与其实例" class="headerlink" title="双向链表与其实例"></a>双向链表与其实例</h3><ol><li><p>双向链表实现实际上对比单向链表多了一个<code>pre</code>属性,大部分功能相似</p></li><li><p>使用双向链表实现水浒传英雄增删改查思路图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324090248833.png" class="" title="image-20230324090248833"></li><li><p>删除部分代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 5. 从双向链表中删除一个节点</span></span><br><span class="line"><span class="comment">      * 说明:</span></span><br><span class="line"><span class="comment">      * 1.对于双向链表,我们可以直接找到要删除的这个节点</span></span><br><span class="line"><span class="comment">      * 2.找到后,自我删除即可</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;链表为空,无法删除&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;<span class="comment">//辅助遍历(指针)</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标识是否找到待删除节点</span></span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//已经到了链表最后</span></span><br><span class="line">             <span class="keyword">if</span> (temp.no == no) &#123; <span class="comment">//找到待删除的节点</span></span><br><span class="line">                 flag = <span class="literal">true</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             temp = temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">             temp.pre.next = temp.next;<span class="comment">//将下一个节点地址赋值给上一个节点的`next`</span></span><br><span class="line">             <span class="comment">//如果不加判断,可能当前节点是最后一个,导致`temp.next.pre`会出现空指针异常</span></span><br><span class="line">             <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) temp.next.pre = temp.pre;<span class="comment">//将下一个节点的上一个(pre)赋值为当前节点的上一个(pre)</span></span><br><span class="line">         &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>, no);</span><br><span class="line">   </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>全部代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.doublelinked;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">5</span>, <span class="string">&quot;666&quot;</span>, <span class="string">&quot;666&quot;</span>);</span><br><span class="line">          <span class="comment">//创建链表对象</span></span><br><span class="line">          <span class="type">DoubleLinkedList</span> <span class="variable">doubleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">          <span class="comment">//1.直接添加到链表尾部</span></span><br><span class="line">          doubleLinkedList.add(hero1);</span><br><span class="line">          doubleLinkedList.add(hero2);</span><br><span class="line">          doubleLinkedList.add(hero3);</span><br><span class="line">          doubleLinkedList.add(hero4);</span><br><span class="line">          doubleLinkedList.list();</span><br><span class="line">          <span class="comment">//修改测试</span></span><br><span class="line">          System.out.println(<span class="string">&quot;测试修改林冲&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">4</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;零充&quot;</span>);</span><br><span class="line">          doubleLinkedList.update(newHeroNode);</span><br><span class="line">          doubleLinkedList.list();</span><br><span class="line">          <span class="comment">//删除测试</span></span><br><span class="line">          System.out.println(<span class="string">&quot;测试删除吴用&quot;</span>);</span><br><span class="line">          doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">          doubleLinkedList.list();</span><br><span class="line">          <span class="comment">//测试插入添加</span></span><br><span class="line">          <span class="comment">//1.直接添加到链表尾部</span></span><br><span class="line">          System.out.println(<span class="string">&quot;测试插入添加 &quot;</span>);</span><br><span class="line">          doubleLinkedList.addByOrder(hero5);</span><br><span class="line">          doubleLinkedList.addByOrder(hero3);</span><br><span class="line">          doubleLinkedList.list();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">      <span class="comment">//1. 先初始化一个头节点,头节点不要动,不存放具体的数据</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">DoubleHeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 返回头节点,get方法</span></span><br><span class="line">      <span class="keyword">public</span> DoubleHeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 添加一个节点节点到双向链表的最后</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(DoubleHeroNode heroNode)</span> &#123;</span><br><span class="line">          <span class="comment">//因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">          <span class="comment">//遍历链表,找到最后</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="comment">//找到链表的最后:当next值为空,就是最后一位</span></span><br><span class="line">              <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">//如果没有找到最后,就将temp向后移动,不然就原地踏步死循环了</span></span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//当退出while循环的时候,temp就指向了链表的最后</span></span><br><span class="line">          <span class="comment">//形成一个双向链表</span></span><br><span class="line">          temp.next = heroNode;</span><br><span class="line">          heroNode.pre = temp;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.1 按照no进行对双向链表的插入,课堂练习题</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(DoubleHeroNode heroNode)</span> &#123;</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;<span class="comment">//需要找到要添加位置的前一个节点</span></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明已经遍历到链表最后</span></span><br><span class="line">              <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) <span class="keyword">break</span>;<span class="comment">//说明已经找到,就在temp后面插入</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明已经存在重复no</span></span><br><span class="line">                  flag = <span class="literal">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag) System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了,不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              heroNode.next = temp.next; <span class="comment">//将temp的下next赋值到要插入的节点的next</span></span><br><span class="line">              heroNode.pre = temp;  <span class="comment">//将temp作为heroNode的pre(上一位)</span></span><br><span class="line">              temp.next = heroNode; <span class="comment">//在找到的位置后面插入heroNode ,并且这里不用判断非空</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4. 修改节点信息,</span></span><br><span class="line">      <span class="comment">//可以看到双向链表的节点内容修改与单向链表一样,只是节点类型改变</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(DoubleHeroNode newHeroNode)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">//找到需要修改的节点,根据no编号</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">//表示当前到链表尾端</span></span><br><span class="line">              <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;<span class="comment">//表示找到该节点了</span></span><br><span class="line">                  flag = <span class="literal">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;<span class="comment">//根据flag可以判断是否找到要修改的节点</span></span><br><span class="line">              temp.name = newHeroNode.name;</span><br><span class="line">              temp.nickname = newHeroNode.nickname;</span><br><span class="line">          &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;没有找到编号%d的阶段,不能进行修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 5. 从双向链表中删除一个节点</span></span><br><span class="line"><span class="comment">       * 说明:</span></span><br><span class="line"><span class="comment">       * 1.对于双向链表,我们可以直接找到要删除的这个节点</span></span><br><span class="line"><span class="comment">       * 2.找到后,自我删除即可</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;链表为空,无法删除&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;<span class="comment">//辅助遍历(指针)</span></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标识是否找到待删除节点</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//已经到了链表最后</span></span><br><span class="line">              <span class="keyword">if</span> (temp.no == no) &#123; <span class="comment">//找到待删除的节点</span></span><br><span class="line">                  flag = <span class="literal">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              temp = temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">              temp.pre.next = temp.next;<span class="comment">//将下一个节点地址赋值给上一个节点的`next`</span></span><br><span class="line">              <span class="comment">//如果不加判断,可能当前节点是最后一个,导致`temp.next.pre`会出现空指针异常</span></span><br><span class="line">              <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) temp.next.pre = temp.pre;<span class="comment">//将下一个节点的上一个(pre)赋值为当前节点的上一个(pre)</span></span><br><span class="line">          &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>, no);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//7. 显示链表[遍历]</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">//判断链表是否为空</span></span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">//输出节点信息</span></span><br><span class="line">              System.out.println(temp);</span><br><span class="line">              <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//一、定义一个HeroNode,每个HeroNode对象就是一个节点</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">DoubleHeroNode</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">      <span class="keyword">public</span> String name;</span><br><span class="line">      <span class="keyword">public</span> String nickname;</span><br><span class="line">      <span class="keyword">public</span> DoubleHeroNode next;<span class="comment">//指向下一个节点,默认为null</span></span><br><span class="line">      <span class="keyword">public</span> DoubleHeroNode pre;<span class="comment">//指向前一个节点,默认为null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//构造器</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">DoubleHeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.no = no;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">          <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//为了显示方法,我们重新toString</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="单向与双向链表对比"><a href="#单向与双向链表对比" class="headerlink" title="单向与双向链表对比"></a>单向与双向链表对比</h3><ol><li><p>管理单向链表相较于双向链表的缺点分析</p><ul><li>① 单链表只有一个指向下一结点的指针，也就是只能next; ② 双链表除了有一个指向下一结点的指针外，还有一个指向前一结点的指针，可以通过prev()快速找到前一结点，顾名思义，单链表只能单向读取</li><li>单向链表不能自我删除，需要靠辅助节点 ，而双向链表则可以自我删除，所以前面我们单链表删除时节点，总是找到 temp,temp 是待删除节点的前一个节点,双向链表则是可以直接将temp指向要删除的节点</li></ul></li><li><p>双链表具有以下优点:</p><ul><li>删除单链表中的某个结点时，一定要得到待删除结点的前驱，得到该前驱有两种方法，第一种方法是在定位待删除结点的同时一路保存当前结点的前驱。第二种方法是在定位到待删除结点之后，重新从单链表表头开始来定位前驱。尽管通常会采用方法一。但其实这两种方法的效率是一样</li><li>查找时也一样，我们可以借用二分法的思路，从head（首节点）向后查找操作和last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍</li></ul></li><li><p><code>面试官</code>：从你的描述来看，双链表的在查找、删除的时候可以利用二分法的思想去实现,但是为什么目前市场应用上<code>单链表的应用要比双链表的应用要广泛</code>的多呢?</p><ul><li>从存储结构来看，每个双链表的节点要比单链表的节点多一个指针，而长度为n就需要 n*length（这个指针的length在32位系统中是4字节，在64位系统中是8个字节） 的空间，这在一些追求时间效率不高应用下并不适应，因为它占用空间大于单链表所占用的空间；这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。</li></ul></li><li><p>结构对比图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324090646504.png" class="" title="image-20230324090646504"></li></ol><h3 id="单向环形链表之约瑟夫问题"><a href="#单向环形链表之约瑟夫问题" class="headerlink" title="单向环形链表之约瑟夫问题"></a>单向环形链表之<code>约瑟夫问题</code></h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol><li><p><code>约瑟夫</code>（ <em>Josephu</em> ） 问题是一个非常著名的有趣的题目。问题具体描述如下：</p><blockquote><p>设编号分别为1、2、3… n 的 n 个人围坐一圈，约定编号为 k（1≤k≤n）的人从 1 开始报数，数到 m 的那个人出列。出列的人的下一位又从 1 开始报数，数到 m 的那个人继续出列。以此类推，直到所有人都出列为止，由此产生一个出队编号的序列，这个序列也就是约瑟夫问题的解。</p></blockquote></li><li><p>下面将用一个动图来描述一下这个问题</p><blockquote><p>假设有 4 个人围坐一圈，约定编号为 1 的人开始报数，数到 3 的那个出列。最后产生的出队编号的序列将会是：3、2、4、1。</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E5%9B%BE%E8%A7%A3.gif" class="" title="image-20230324090844251"></blockquote></li></ol><h4 id="思路实现"><a href="#思路实现" class="headerlink" title="思路实现"></a>思路实现</h4><ol><li><p>用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p></li><li><p>约瑟夫问题-创建环形链表的思路图解</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324090951439.png" class="" title="image-20230324090951439"></li><li><p>约瑟夫问题-小孩出圈的思路分析图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324091007521.png" class="" title="image-20230324091007521"></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.josepfu;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Josepfu</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">int</span> NUM=<span class="number">5</span>;<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">          <span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">          <span class="type">CircleSingleLinkedList</span> <span class="variable">circleSingleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleSingleLinkedList</span>();</span><br><span class="line">          circleSingleLinkedList.addBoy(NUM);</span><br><span class="line">          circleSingleLinkedList.showBoy();</span><br><span class="line">          <span class="comment">//测试一把小孩出圈是否正确</span></span><br><span class="line">          circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, NUM); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二、创建一个环形的单向链表</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span> &#123;</span><br><span class="line">      <span class="comment">//1. 创建一个first节点,当前没有编号</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 添加小孩节点,构建成一个环形的链表</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span> &#123;</span><br><span class="line">          <span class="comment">//nums做一个数据校验</span></span><br><span class="line">          <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;nums的值不正确&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//辅助指针,帮助构建环形链表</span></span><br><span class="line">          <span class="comment">//使用for来创建我们的环形链表</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums; i++) &#123;<span class="comment">//i从1开始,才能得到编号与数字顺序一样的no;</span></span><br><span class="line">              <span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">              <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">              <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; <span class="comment">//如果fori从0开始遍历,这里也要改为i==0,否则下面 `curBoy.setNext(boy);`将空指针异常</span></span><br><span class="line">                  first = boy;</span><br><span class="line">                  first.setNext(first); <span class="comment">//构成环,即只有一个时自己指向自己</span></span><br><span class="line">                  curBoy = first;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  boy.setNext(first); <span class="comment">//将当前次循环的next指向第一个节点形成环</span></span><br><span class="line">                  curBoy.setNext(boy);<span class="comment">//此处curBoy标记的是上一次循环的boy 如`i==2`--&gt;curBoy==first、`i==3`--&gt;curBoy==boy(第二个)</span></span><br><span class="line">                  curBoy = boy;  <span class="comment">//这一步是移动当前curBoy位置到boy,保存当前boy 用作在下轮循环中指定当前boy的next</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 遍历当前环形链表</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;没有任何小孩~~~~&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              System.out.printf(<span class="string">&quot;小孩编号%d\n&quot;</span>, curBoy.getNo());</span><br><span class="line">              <span class="keyword">if</span> (curBoy.getNext() == first) <span class="keyword">break</span>;</span><br><span class="line">              curBoy = curBoy.getNext();<span class="comment">//curBoy后移</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * //4. 根据用户输入,计算小孩出圈的顺序</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> startNo  开始的位置</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> countNum 每次循环的数字</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> nums     单纯用来校验循环次数是否多于总长度</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo, <span class="type">int</span> countNum, <span class="type">int</span> nums)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (first == <span class="literal">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;参数输入有误,请重新输入&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//①创建一个辅助指针,帮助完成小孩出圈</span></span><br><span class="line">          <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">          <span class="comment">//②将辅助指针事先指向环形列表的最后这个节点(即next指向first)</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helper.getNext() == first) <span class="keyword">break</span>;<span class="comment">//说明helper指向最后的小孩节点</span></span><br><span class="line">              helper = helper.getNext();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//③小孩报数前,先让first和helper移动K-1次(如果我是从3开始,我需要事先指向3的位置)</span></span><br><span class="line">          <span class="comment">//为什么是K-1次--&gt;因为循环i是从0开始的</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">              first = first.getNext();</span><br><span class="line">              helper = helper.getNext();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//④出圈删除:当小孩报数时,让first和helper指针同时移动m-1次,然后出圈</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helper == first) <span class="keyword">break</span>; <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">              <span class="comment">//让first和helper指针同时移动countNum-1次</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                  first = first.getNext();</span><br><span class="line">                  helper = helper.getNext();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//出了for循环后,此时first指向的节点就是要出圈的小孩节点</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;小孩%d出圈\n&quot;</span>, first.getNo());</span><br><span class="line">              <span class="comment">//此时将first指向的小孩节点出圈</span></span><br><span class="line">              first = first.getNext();</span><br><span class="line">             <span class="comment">//注意:此处用的时setNext--&gt;这步就是删除操作,原来的first指向的节点没有任何引用的时候,就会被回收</span></span><br><span class="line">              helper.setNext(first);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号%d\n&quot;</span>, first.getNo());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//一、创建一个Boy类,表示一个节点</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">//编号</span></span><br><span class="line">      <span class="keyword">private</span> Boy next; <span class="comment">//指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.no = no;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> no;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.no = no;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.next = next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="思路改进与代码实现"><a href="#思路改进与代码实现" class="headerlink" title="思路改进与代码实现"></a>思路改进与代码实现</h4><p>将该问题解决思想带入 实现水浒传英雄</p><ol><li><p>思路解析:</p><blockquote><ol><li><p>首先要确定解决问题的核心思想：<code>使用一个不带头结点的循环(环形)链表来处理该问题</code>。</p></li><li><p>假设每个结点代表一个人，那么一个由 n 个结点组成的循环链表就相当于是 n 个人围成的一个圈。那么约瑟夫问题以环形链表的形式来描述就是如下情景：</p></li></ol><blockquote><p>首先使用 n 个结点构成一个单向循环链表，然后由第 k 个结点起从 1 开始计数，当计到 m 时，从链表中删除对应结点；接着从被删除结点的下一个结点开始从 1 计数，当计到 m 时，继续从链表中删除。依次循环往复，直到链表中的所有结点都被删除为止。</p></blockquote><ol start="3"><li>那么对于这个单向循环链表形式下的约瑟夫问题，我们如何解决呢？</li></ol><ul><li><p>我们可以引入一个辅助指针 helperNode，这个指针总是指向待删除结点的前一个结点。为什么这个辅助指针要指向待删除结点的前一个结点，而不是指向自身呢？</p></li><li><p>因为我们的目的是要删除当前计数为 m 的结点，但是受限于单向链表的特性（如果要删除单链表的某个结点，必须要知道该结点的前一个结点），我们无法让结点自己删除自己。鉴于这个特性，我们必须要引入一个辅助指针来记录当前正在计数的结点的前一个结点，这样才能符合删除条件的结点从链表中删除。</p></li></ul></blockquote></li><li><p>引入这个辅助指针之后，具体的操作思路如下:</p><blockquote><ol><li>每一轮计数开始时，总让辅助指针 helperNode 初始指向本轮第一个计数的结点；</li><li>从第一个计数的结点开始计数至 m，实际上是向后移动了 m-1 个结点。由于辅助指针总是指向待删除结点的前一个结点，因此让需要让辅助指从第一个计数结点后移 m-2 个结点；</li><li>辅助指针移动到待删除结点的前一个结点之后，只需要让辅助指针指向待删除的结点的下一个结点即可完成删除操作；</li><li>依次循环往复，直至只剩最后一个结点；</li><li>对于环形链表判断是否只有最后一个结点，只需要判断辅助指针指向的结点是否是辅助指针指向的结点的下一个结点即可。</li></ol></blockquote></li><li><p>上面的思路可以用下面一个动图来描述:</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%E5%9B%BE2.gif" class="" title="image-20230324091251984"></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.doublelinked;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程外思路实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造测试数据</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;公孙胜&quot;</span>, <span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;码农&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;努力学习的汪&quot;</span>, <span class="string">&quot;学习狗&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============向环形链表中插入结点==================&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">first</span> <span class="operator">=</span> insertCircleList(<span class="literal">null</span>, node_1);</span><br><span class="line">        first = insertCircleList(first, node_2);</span><br><span class="line">        first = insertCircleList(first, node_3);</span><br><span class="line">        first = insertCircleList(first, node_4);</span><br><span class="line">        first = insertCircleList(first, node_5);</span><br><span class="line">        first = insertCircleList(first, node_6);</span><br><span class="line">        showList(first);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============约瑟夫游戏开始===============&quot;</span>);</span><br><span class="line">        <span class="comment">// 从第 1 个结点开始计数，每次计 3 个数。</span></span><br><span class="line">        josepfuGame(first, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 1. 约瑟夫游戏开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> [first, k, m]   头节点,从第 k 个人开始数，每次数 m 个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">josepfuGame</span><span class="params">(HeroNode first, <span class="type">int</span> k, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">helperNode</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="comment">// 首先要移动到第 k 个结点，此时辅助指针初始指向第一个计数的结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            helperNode = helperNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (helperNode.next.getNo() != helperNode.getNo()) &#123;</span><br><span class="line">            <span class="comment">// 报数， m 个数也就是相当于向后移动 m-1 次，也就是要把第 m-1 个结点去掉</span></span><br><span class="line">            <span class="comment">// 由于单链表的特点，要去掉第 m-1 个结点，肯定是要让指针前一个结点，即第(m-2)个结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m - <span class="number">2</span>; j++) &#123;  <span class="comment">// 让指针后移 m-2 个结点</span></span><br><span class="line">                helperNode = helperNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(helperNode.next + <span class="string">&quot;退出链表了!&quot;</span>);</span><br><span class="line">            <span class="comment">// 删除结点</span></span><br><span class="line">            helperNode.next = helperNode.next.next;</span><br><span class="line">            <span class="comment">// 因为下一轮要从刚刚去掉的结点的后面一个结点开始计数了，所以需要让辅助指针初始指向下一轮第一个计数的结点</span></span><br><span class="line">            helperNode = helperNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(helperNode + <span class="string">&quot;退出链表了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 2. 插入结点到环形链表中，用于构造环形链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">insertCircleList</span><span class="params">(HeroNode first, HeroNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是不是为空，如果为空，就直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = node;</span><br><span class="line">            <span class="comment">// 因为要环形链表，而且只有一个结点，所以要我指向我自己</span></span><br><span class="line">            first.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果环形链表不为空</span></span><br><span class="line">            <span class="type">HeroNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> first;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果到了环形链表的最后一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (tempNode.next.getNo() == first.getNo()) &#123;</span><br><span class="line">                    tempNode.next = node;</span><br><span class="line">                    <span class="comment">// 因为是环形链表，所以最后一个结点还要指向第一个结点</span></span><br><span class="line">                    node.next = first;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tempNode = tempNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 3. 打印单向环形链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showList</span><span class="params">(HeroNode first)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempNode.next.getNo() == first.getNo()) &#123;</span><br><span class="line">                System.out.println(tempNode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(tempNode);</span><br><span class="line">            tempNode = tempNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;             <span class="comment">// 本节点数据</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;       <span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方法,我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickName + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装nginx</title>
      <link href="/2018/03/14/MD-CentOS7/centos7%E5%AE%89%E8%A3%85nginx/"/>
      <url>/2018/03/14/MD-CentOS7/centos7%E5%AE%89%E8%A3%85nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="下载nginx安装包"><a href="#下载nginx安装包" class="headerlink" title="下载nginx安装包"></a>下载nginx安装包</h2><p>进入官网下载页面，建议下载稳定版本</p><p><a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p><p>下载完成后上传到centos</p><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>安装依赖包</p><p>由于nginx是基于c语言开发的，所以需要安装c语言的编译环境，及正则表达式库等第三方依赖库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><p>解压nginx压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.22.1.tar.gz</span><br></pre></td></tr></table></figure><p>配置nginx编译环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.22.1</span><br><span class="line">./configure --prefix=/opt/moudle/nginx</span><br></pre></td></tr></table></figure><p><code>说明</code>: –prefix 指定的目录，就是我们安装Nginx的目录。</p><p>编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看版本</span></span><br><span class="line">./nginx -v</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查配置文件，修改了nginx.conf核心配置文件之后，在启动Nginx服务之前，可以先检查一下conf/nginx.conf文件配置的是否有错误，命令如下：</span></span><br><span class="line">./nginx -t</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">./nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动之后，我们可以通过ps -ef指令来查看nginx的进程是否存在。</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止</span></span><br><span class="line">./nginx -s stop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新加载，当修改了Nginx配置文件后，需要重新加载才能生效，可以使用下面命令重新加载配置文件：</span></span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="nginx-conf配置"><a href="#nginx-conf配置" class="headerlink" title="nginx.conf配置"></a>nginx.conf配置</h2><h3 id="配置静态网页"><a href="#配置静态网页" class="headerlink" title="配置静态网页"></a>配置静态网页</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">           </span><br><span class="line">            root   /opt/moudle/hexo-blog/public; #服务器上存放静态网页的目录</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Hexo</title>
      <link href="/2018/03/13/MD-Hexo/%E5%AE%89%E8%A3%85Hexo/"/>
      <url>/2018/03/13/MD-Hexo/%E5%AE%89%E8%A3%85Hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，然后<code>cd</code>到这个文件夹下，打开命令终端</p><h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>依旧用<code>hexo -v</code>查看一下版本</p><p>至此就全部安装完了。</p><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p><code>注意</code>,这里的命令都是作用在刚刚创建的Blog文件夹中。</p><p>然后cd到blog目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p>打开hexo的服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>在浏览器输入localhost:4000就可以看到你生成的博客了。</p><h2 id="Hexo-必装插件"><a href="#Hexo-必装插件" class="headerlink" title="Hexo 必装插件"></a>Hexo 必装插件</h2><h3 id="Hexo-asset-img"><a href="#Hexo-asset-img" class="headerlink" title="Hexo-asset-img"></a>Hexo-asset-img</h3><p>自动为文章中的图片提供绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><p>设置 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>比如新建一片博客名为 hexo-plugin，那么在创建文章 md 文件的同时会创建一个 hexo-plugin 的目录，文章对应的图片放入这个目录就行。</p><p>Typora 可以将图像设为 <code>$&#123;filename&#125;</code> 便可自动适配</p><h3 id="hexo-generator-search"><a href="#hexo-generator-search" class="headerlink" title="hexo-generator-search"></a>hexo-generator-search</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>配置根目录下的 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span> <span class="string">./search.xml</span></span><br></pre></td></tr></table></figure><p>最后需要导入搜索的模板文件 search.xml 文件到主题文件中，这个文件可以去 <a href="https://github.com/wzpan/hexo-generator-search">https://github.com/wzpan/hexo-generator-search</a> 下载，也可以在刚刚安装的依赖包中找到，具体地址为 node_modules/hexo-generator-search/demo_output/search.xml</p><p>修改 主題配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br></pre></td></tr></table></figure><h2 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h2><h3 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h3><p>一款很精致简单，但功能强大的主题。</p><p>主要有以下特点：</p><ol><li>Material Design 设计，简单漂亮，文章内容美观易读；</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现；</li><li>功能多，支持友链、评论模块、文章统计、音乐播放、视频播放等。</li></ol><ul><li>Github 地址：**<a href="https://link.zhihu.com/?target=https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a>**</li><li>安装教程：<a href="https://link.zhihu.com/?target=https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></li></ul><h2 id="hexo部署在github"><a href="#hexo部署在github" class="headerlink" title="hexo部署在github"></a>hexo部署在github</h2><h3 id="在github上创建项目"><a href="#在github上创建项目" class="headerlink" title="在github上创建项目"></a>在github上创建项目</h3><p>新建一个项目，然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。</p><img src="/2018/03/13/MD-Hexo/%E5%AE%89%E8%A3%85Hexo/image-20230312220906008.png" class="" title="image-20230312220906008"><p>然后项目就建成了</p><h3 id="配置根目录下的-config-yml"><a href="#配置根目录下的-config-yml" class="headerlink" title="配置根目录下的 _config.yml"></a>配置根目录下的 <code>_config.yml</code></h3><p>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:lijianjun821/lijianjun821.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>repository修改为你自己的github项目地址。</p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>首先在博客根目录下右键打开git bash，安装一个扩展</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><p>生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>然后输入hexo s可以本地预览效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>最后输入hexo d上传到github上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时打开你的github.io主页就能看到发布的文章啦。</p><p><a href="https://lijianjun821.github.io/">https://lijianjun821.github.io/</a></p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>1.首先解析域名,添加两条解析记录</p><img src="/2018/03/13/MD-Hexo/%E5%AE%89%E8%A3%85Hexo/image-20230312223119954.png" class="" title="image-20230312223119954"><p>2.打开你本地博客/source目录，新建CNAME文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行hexo g、hexo d上传到github</p><p>3.使用域名<code>jianjunw.com</code>访问bolg</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac安装常用软件</title>
      <link href="/2018/03/12/MD-Mac/mac%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
      <url>/2018/03/12/MD-Mac/mac%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="mac安装svn"><a href="#mac安装svn" class="headerlink" title="mac安装svn"></a>mac安装svn</h2><ol><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install svn</span><br></pre></td></tr></table></figure></li><li><p>查看svn安装目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info svn</span><br></pre></td></tr></table></figure></li><li><p>常用命令</p><ul><li><p>从svn上拉取代码到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn checkout https://192.168.0.2/svn/XXX/XXX /Users/lijianjun/test</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><code>问题小记</code>：在Mac上安装<a href="https://so.csdn.net/so/search?q=SVN&spm=1001.2101.3001.7020">SVN</a>是如果缺少相关依赖包，则会出现类似标题的报错信息</p><img src="/2018/03/12/MD-Mac/mac%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/801969f78f8947febb48d464a605b10e.png" class="" title="img"><p>说明缺少相关依赖包，再次执行<a href="https://so.csdn.net/so/search?q=brew&spm=1001.2101.3001.7020">brew</a> install apr命令安装相关依赖包。</p><p>最后再重新执行brew install subversion命令则可以成功安装。</p><p>通过brew list可查看当前的安装文件</p><img src="/2018/03/12/MD-Mac/mac%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/fb8e31769f094b62aee27d4950b79480.png" class="" title="img">]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac 安装 nodejs</title>
      <link href="/2018/03/12/MD-Mac/mac%20%E5%AE%89%E8%A3%85%20nodejs/"/>
      <url>/2018/03/12/MD-Mac/mac%20%E5%AE%89%E8%A3%85%20nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h2><p>可参考官方最新安装命令</p><p><a href="https://github.com/nvm-sh/nvm#install-script">https://github.com/nvm-sh/nvm#install-script</a></p><h3 id="Install-amp-Update-Script"><a href="#Install-amp-Update-Script" class="headerlink" title="Install &amp; Update Script"></a>Install &amp; Update Script</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br><span class="line">或</span><br><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm -v</span><br><span class="line"></span><br><span class="line">nvm list</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果报错：</p><p>curl: (7) Failed to connect to raw.githubusercontent.com port 443 after 3 ms: Connection refused</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原因是发现是 github 的一些域名的 DNS 解析被污染，导致DNS 解析过程无法通过域名取得正确的IP地址</span><br><span class="line">解决方案</span><br><span class="line">打开 https://www.ipaddress.com/ 输入访问不了的域名</span><br><span class="line">查询之后可以获得正确的 IP 地址（任意一个即可）</span><br><span class="line">在本机的 host 文件中添加 ，可以使用switchhosts软件管理host</span><br><span class="line">185.199.108.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><p>如果报错 zsh: command not found: nvm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Troubleshooting on Linux</span><br><span class="line"></span><br><span class="line">On Linux, after running the install script, if you get nvm: command not found or see no feedback from your terminal after you type command -v nvm, simply close your current terminal, open a new terminal, and try verifying again. Alternatively, you can run the following commands for the different shells on the command line:</span><br><span class="line"></span><br><span class="line">bash: source ~/.bashrc</span><br><span class="line"></span><br><span class="line">zsh: source ~/.zshrc</span><br><span class="line"></span><br><span class="line">ksh: . ~/.profile</span><br><span class="line"></span><br><span class="line">These should pick up the nvm command.</span><br></pre></td></tr></table></figure><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><h3 id="nvm管理nodejs版本"><a href="#nvm管理nodejs版本" class="headerlink" title="nvm管理nodejs版本"></a>nvm管理nodejs版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最新的lts版本</span> </span><br><span class="line">nvm install --lts </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本号下载(v要不要都可以)</span> </span><br><span class="line">nvm install v10.16.3</span><br></pre></td></tr></table></figure><h3 id="切换node版本："><a href="#切换node版本：" class="headerlink" title="切换node版本："></a>切换node版本：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">macOS系统的use指令只是临时切换</span> </span><br><span class="line">nvm alias default v10.16.3 </span><br></pre></td></tr></table></figure><h3 id="配置淘宝镜像："><a href="#配置淘宝镜像：" class="headerlink" title="配置淘宝镜像："></a>配置淘宝镜像：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global  </span><br><span class="line"></span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure><h3 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm -v </span><br><span class="line">npx -v </span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><h2 id="nvm常用命令"><a href="#nvm常用命令" class="headerlink" title="nvm常用命令"></a>nvm常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nvm install --lts # 下载最新的稳定版 </span><br><span class="line">nvm use &lt;版本号&gt; # 临时切换版本 </span><br><span class="line">nvm alias default &lt;版本号&gt; #永久切换版本（版本别名，default就是默认使用的版本） </span><br><span class="line">nvm uninstall &lt;版本号&gt; # 删除指定版本 </span><br><span class="line">nvm ls # 查看本地所有版本 </span><br><span class="line">nvm ls-remote --lts # 查看线上所有稳定版 </span><br></pre></td></tr></table></figure><h2 id="node常用命令"><a href="#node常用命令" class="headerlink" title="node常用命令"></a>node常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm init # 初始化node环境，-y可以快速初始化 </span><br><span class="line">npm i &lt;package&gt; # 下载指定库，看情况添加 -S或者-D，全局安装-g </span><br><span class="line">npm uninstall &lt;package&gt; # 删除node包，删除全局-g </span><br><span class="line">npm list --depth 0 # 查看当前目录下载的node包 </span><br><span class="line">npm list -g --depth 0 # 查看全局安装的node包</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构与算法概述"><a href="#数据结构与算法概述" class="headerlink" title="数据结构与算法概述"></a>数据结构与算法概述</h2><h3 id="1、数据结构和算法的关系"><a href="#1、数据结构和算法的关系" class="headerlink" title="1、数据结构和算法的关系"></a>1、数据结构和算法的关系</h3><ul><li>数据 data 结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以 编写出更加漂亮,更加有效率的代码。 </li><li>要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决. </li><li><code>程序 = 数据结构 + 算法</code></li><li>数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。</li></ul><h3 id="2、线性结构与非线性结构"><a href="#2、线性结构与非线性结构" class="headerlink" title="2、线性结构与非线性结构"></a>2、线性结构与非线性结构</h3><p>​    &emsp;&emsp;数据结构包括：线性结构和非线性结构。</p><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><ul><li><p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系 </p></li><li><p>线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序 表，顺序表中的存储元素是连续的 </p></li><li><p>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地 址信息 </p></li><li><p>线性结构常见的有：数组、队列、链表和栈</p></li></ul><h4 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h4><p>&emsp;&emsp;非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p><hr><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h3><ul><li>队列是一个有序列表，可以用数组或是链表来实现。</li><li>遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li></ul><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210413170353329.png" class="" title="image-20210413170353329"> <h3 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h3><ol><li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图, 其中 maxSize 是该队列的最大容量。 </p></li><li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如队列介绍中图所示</p></li><li><p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析:</p><blockquote><ul><li><p>将尾指针往后移：rear+1 , 当 front == rear 【空】 </p></li><li><p>若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据</p></li></ul></blockquote></li><li><p><code>注意</code>:front并没有直接指向数据,而是数据前一位,所以当你要用front读取队列头时需要<code>front+1</code></p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//创建一个队列</span></span><br><span class="line">         <span class="type">ArrayQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">         <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">         <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="comment">//输出一个菜单</span></span><br><span class="line">         <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">             System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">             System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">             System.out.println(<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">             System.out.println(<span class="string">&quot;h(head):查看队列头的数据&quot;</span>);</span><br><span class="line">             key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接受一个字符</span></span><br><span class="line">             <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                     queue.showQueue();</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                     System.out.println(<span class="string">&quot;输入一个数字&quot;</span>);</span><br><span class="line">                     <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">//不用再new一个新得scanner</span></span><br><span class="line">                     queue.addQueue(value);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue.getQueue();</span><br><span class="line">                         System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                         System.out.println(e.getMessage());</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> queue.headQueue();</span><br><span class="line">                         System.out.printf(<span class="string">&quot;表头是%d\n&quot;</span>, head);</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                         System.out.println(e.getMessage());</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">default</span>:</span><br><span class="line">                     scanner.close();<span class="comment">//关闭不释放会有异常</span></span><br><span class="line">                     loop = <span class="literal">false</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> front; <span class="comment">//队列头</span></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span>[] arr; <span class="comment">//该数据用于存放数据,模拟队列</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//创建队列的构造器</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">         maxSize = arrMaxSize;</span><br><span class="line">         arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">         front = -<span class="number">1</span>;<span class="comment">//指向队列头部,分析出front是只想队列头的前一个位置</span></span><br><span class="line">         rear = -<span class="number">1</span>;<span class="comment">//指向队列尾部,只想队列尾部数据(即队列最后一个数据)</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//1. 判断队列是否满</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>; <span class="comment">//当队列为指向数组最后一位时就是队列满</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//2. 判断队列是否为空</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> rear == front; <span class="comment">//当队列头与尾部相等时,说明该队列没有值了</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//3. 添加数据到队列</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="comment">//判断队列是否满</span></span><br><span class="line">         <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;队列满,不能加入数据~~~~~~&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         rear++; <span class="comment">//让rear 往后移动一位</span></span><br><span class="line">         arr[rear] = n; <span class="comment">//以后移后的rear作为数组下标进行赋值</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4. 获取队列的数据,出队列</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//判断队列是否为空//抛出异常</span></span><br><span class="line">         <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">         front++; <span class="comment">//front后移 出队列</span></span><br><span class="line">         <span class="keyword">return</span> arr[front];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//5. 显示队列的所有数据</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//遍历</span></span><br><span class="line">         <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;队列空的 没有数据&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">             System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i, arr[i]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//显示队列的头数据,注意不是取出数据</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//判断</span></span><br><span class="line">         <span class="keyword">if</span> (isEmpty())  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空的,没有数据~~~~&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> arr[front + <span class="number">1</span>]; <span class="comment">//front并没有直接指向数据,而是数据前一位,所以需要+1</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>问题分析与优化方向</p><blockquote><ol><li>目前数组使用一次就不能用， 没有达到复用的效果.</li></ol><p> ​    <code>原因</code>:取出数据时是将列表头(<code>front++</code>)向后移动,导致队列前面的空间并没有被释放,如上图第三个队列示例图 </p><ol start="2"><li>将这个数组使用算法，改进成一个环形的队列 取模：%</li></ol></blockquote></li></ol><h3 id="数组模拟环形队列思路分析"><a href="#数组模拟环形队列思路分析" class="headerlink" title="数组模拟环形队列思路分析"></a>数组模拟环形队列思路分析</h3><ol><li><p>对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p></li><li><p>分析说明:</p><blockquote><ol><li><p>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize == front 满]</p></li><li><p>rear == front [空]</p></li></ol></blockquote></li><li><p>思路分析示例图</p></li></ol><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210413180656594.png" class="" title="image-20210413180656594"><ol start="4"><li><p>环形队列示例图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210413180729037.png" class="" title="image-20210413180729037"></li></ol><h3 id="个人对于环形队列的理解与总结"><a href="#个人对于环形队列的理解与总结" class="headerlink" title="个人对于环形队列的理解与总结"></a>个人对于环形队列的理解与总结</h3><ol><li><p><code>rear</code>初始化为0:因为当队列为空时,<code>rear</code>队列尾应是指向<code>-1</code>位置,因为整个队列是空的</p><blockquote><p>所以符合调整:rear指向队列的最后一个元素的后一个位置,可以留出一个空间作为约定(用来<code>判断是队空还是队满</code>)</p></blockquote></li><li><p><code>front</code>初始化为0:因为要指向队列第一个位置,所以为0</p></li><li><p>队列满条件:<code>(rear+1)%maxSize==front</code>–&gt;原理如上方环形队列示例图</p><blockquote><p>当<code>(rear+1)%maxSize==front</code>时,队列情况如环形队列示例图右边部分 –&gt;例: (4+1)%10==5</p></blockquote></li><li><p>队列为空<code>rear==front</code>:假使你队列曾经加到8个数据,所以你<code>rear==8</code>,但当你将队列一个一个取出时front发生如下变化:<code>front==0--&gt;front++*n--&gt;front==8</code>,所以当front==rear==8时,就可以判断队列为空</p></li><li><p>队列的有效数据个数:<code>(rear+maxSize-font)%maxSize</code> –&gt;</p><blockquote><p>提出疑惑:为什么要先加<code>maxSize</code>–&gt;可能出现队尾rear小于队首front的情况</p></blockquote></li></ol><p>  &emsp;&emsp;通过这个环形队列图(里面数字是<code>数组下标</code>不是数据)你应该可以很容易理解:假使队列长8、队尾在2的位置、队首在6的位置</p><p>&emsp;&emsp;解决:如图所示</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210413184647572.png" class="" title="image-20210413184647572"><blockquote><p>再次提出疑惑:我看图上<code>6~2</code>,甚至还用手指去数,明明就是五个数据啊!为什么还能算成<code>4</code>?</p></blockquote><p>​    解:注意<code>rear</code>的定义:rear指向队列的最后一个元素的后一个位置,所以这时候最后一个队列数据是在<code>1</code>的位置,所以<code>6~1</code>是4位</p><h3 id="环形队列代码实现"><a href="#环形队列代码实现" class="headerlink" title="环形队列代码实现"></a>环形队列代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> com.queue;</span><br><span class="line">&gt;<span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayQueueDemo</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//创建一个环形队列</span></span><br><span class="line">  System.out.println(<span class="string">&quot;创建一个环形队列&quot;</span>);</span><br><span class="line">  <span class="type">CircleArrayQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//输出一个菜单</span></span><br><span class="line">  <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">   .....<span class="comment">//同上面队列代码调用,省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">CircleArrayQueue</span> &#123;</span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span> front; <span class="comment">//队列头</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span> rear; <span class="comment">//队列尾部</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//该数据用于存放数据,模拟队列</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//创建队列的构造器</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">CircleArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">  <span class="comment">//注意:如果要能存3个有效数据,arrMaxSize就要为`4`,因为预留了一个位置,所以需要传入的数字要+1</span></span><br><span class="line">  maxSize = arrMaxSize + <span class="number">1</span>;</span><br><span class="line">  arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1. 此处front含义做出调整:front指向队列的第一个元素,也就是说arr[front]就是队列的第一个元素,front的初始值为0*</span></span><br><span class="line"><span class="comment">       * 2.此处rear含义做出调整:rear指向队列的最后一个元素的后一个位置,因为希望空出一个空间作为约定(判断栈满栈空),rear的初始值为0</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      front = rear = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 判断队列是否满</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//此时队满条件发生变化,因为rear预留了一个位置</span></span><br><span class="line">      <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 判断队列是否为空</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> front == rear;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 3.获取队列的有效数量</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> int  此函数结果用来在 遍历队列数组时防止下标越界</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4. 添加数据到队列</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      <span class="comment">//判断是否队满</span></span><br><span class="line">      <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;队列满,不能加入数据~~~~~&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[rear] = n;<span class="comment">//这里需要先赋值再将rear+1,因为rear指向最后一个有效数据</span></span><br><span class="line">      <span class="comment">//让rear后移一位,但是需要注意`%`,因为栈尾可以回到下标为`0`处,原因看我画的图</span></span><br><span class="line">      rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5. 获取队列数据 出队列(类似删除数组第一位)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//判断队列是否为空,抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这里需要先将`front`的值保存下来(或者直接保存arr[front],再去return),因为front此时对应的是第一个有效数据,如果＋1后再返回,将指向错误的有效数据</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">thisFront</span> <span class="operator">=</span> front;</span><br><span class="line">      <span class="comment">//front后移,原因与注意点同rear</span></span><br><span class="line">      front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">      <span class="keyword">return</span> arr[thisFront];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//6. 显示所有队列的数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//先判断是否为空</span></span><br><span class="line">      <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;队列为空,没有数据&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1.首先front指向队列第一位,所以要从front开始遍历</span></span><br><span class="line"><span class="comment">       * 2.结束</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; front + getSize(); i++) &#123;</span><br><span class="line">          System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//7. 显示队列的头数据,注意不是取出数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//判断是否为空</span></span><br><span class="line">      <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空的,没有数据~~~~&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//front是直接指向队列第一位的,所以这里可以直接返回</span></span><br><span class="line">      <span class="keyword">return</span> arr[front];</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表-Linked-List-介绍"><a href="#链表-Linked-List-介绍" class="headerlink" title="链表(Linked List)介绍"></a>链表(Linked List)介绍</h3><ol><li><p>链表是以节点的方式来存储,是链式存储 </p></li><li><p>每一个结点包含 data 域、next 域。其中 next 域存放的是下一个结点的地址(双向链表还有一个<code>prev</code>)</p></li><li><p>如图：发现链表的各个节点不一定是连续存储. </p></li></ol><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323164336413.png" class="" title="image-20230323164336413"><ol start="4"><li><p>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</p></li><li><p>单链表(带头结点) 逻辑结构示意图如下</p></li></ol><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323164423403.png" class="" title="image-20230323164423403"><ol start="6"><li><p>代码描述节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age;<span class="comment">// 本结点的信息</span></span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> ListNode next; <span class="comment">// 下一个结点的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="单链表的应用实例"><a href="#单链表的应用实例" class="headerlink" title="单链表的应用实例"></a>单链表的应用实例</h3><p>&emsp;&emsp;使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作</p><h4 id="添加方法一-在添加英雄时，直接添加到链表的尾部"><a href="#添加方法一-在添加英雄时，直接添加到链表的尾部" class="headerlink" title="添加方法一:在添加英雄时，直接添加到链表的尾部"></a>添加方法一:在添加英雄时，直接添加到链表的尾部</h4><ol><li>思路分析示意图:</li></ol><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323164744040.png" class="" title="image-20230323164744040"><ol start="2"><li><p>演示最基础的链表插入:<code>插入到链表的最后面</code>,不考虑顺序</p><ul><li>首先我们需要创建一个头结点，该结点的作用就是表示单链表的头，如果没有头结点，我们是无法知道链表的首个结点是谁、在哪；</li><li>单链表是单向的，所以我们需要从头结点开始遍历整个链表直到末尾，然后增加结点到链表的末尾；</li><li>需要注意的是，头结点是万万不能乱动的，所以我们最好将头结点复制到一个临时结点变量中，对临时变量进行遍历。</li></ul></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.firstadd;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示最基础的链表插入,插入到链表的最后面,不考虑顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstAdd</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先创建节点对象,一个节点就是一个节点英雄</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="comment">//创建链表对象</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">        <span class="comment">//不按顺序添加</span></span><br><span class="line">        singleLinkedList.add(hero1);</span><br><span class="line">        singleLinkedList.add(hero4);</span><br><span class="line">        singleLinkedList.add(hero2);</span><br><span class="line">        singleLinkedList.add(hero3);</span><br><span class="line">        <span class="comment">//调用打印</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一、定义一个HeroNode,每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了显示方法,我们重新toString;里不打印next,是因为如果这样打印的话,会将整个链表全部打印出来</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二、定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//1. 先初始化一个头节点,头节点不要动,不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 返回头节点,get方法</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 添加节点到单链表后</span></span><br><span class="line"><span class="comment">     * 思路:不考虑编号顺序,直接插入到链表最后</span></span><br><span class="line"><span class="comment">     * 1)找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2)将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表,找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后:当next值为空,就是最后一位</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果没有找到最后,就将temp向后移动,不然就原地踏步死循环了</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环的时候,temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后这个节点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 显示链表[遍历]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="添加方法二-根据排名将英雄插入到指定位置"><a href="#添加方法二-根据排名将英雄插入到指定位置" class="headerlink" title="添加方法二:根据排名将英雄插入到指定位置"></a>添加方法二:根据排名将英雄插入到指定位置</h4><ol><li><p>如果有这个排名(即no重复)，则添加失败，并给出提示</p></li><li><p>思路分析示意图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323165149509.png" class="" title="image-20230323165149509"></li><li><p>代码中实例场景示例图:</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323165226641.png" class="" title="image-20230323165226641"></li><li><p>思路分析:</p><ul><li>首先还是要创建一个头结点，然后拷贝一个头结点作为辅助变量，使用辅助变量来遍历整个链表；</li><li>如果出现某个结点（假设是 A 结点）的下一个结点（假设是 B 结点）的编号大于待插入结点的情况，那么就首先将 B 结点记录在待插入的结点中，然后再将这个待插入结点插入到 A 结点之后；</li><li>如果遍历到了链表末尾还没找到编号更大的，就直接插入到末尾即可。</li></ul></li><li><p>代码实现:(只是将第一方法代码示例中的<code>add()</code>替换未<code>addByOrder</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">    <span class="comment">/*因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line"><span class="comment">       因为单链表,所以我们找的temp 必须为于添加位置的前一个节点,否则插入不了*/</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//flag标识添加的编号是否存在,默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明temp已经在链表的最后,就在链表插入(此时temp已经在链表尾部了)</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) <span class="keyword">break</span>;<span class="comment">//说明位置已经找到,就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode编号已经存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//temp后移,直到找到符合上面条件为止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了,不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将heroNode插入到链表的temp后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------- main()中调用  ------------------------</span><br><span class="line"> singleLinkedList.addByOrder(hero2);</span><br><span class="line"> singleLinkedList.addByOrder(hero4);</span><br><span class="line"> singleLinkedList.addByOrder(hero4);</span><br></pre></td></tr></table></figure></li></ol><h4 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h4><ol><li><p>思路(1) 先找到该节点，通过遍历，(2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname</p><ul><li>首先还是要创建一个头结点，然后拷贝一个头结点作为辅助变量，使用辅助变量来遍历整个链表；</li><li>遍历过程中，比对每个结点的编号与要更新的结点的编号是否一致，如果一致则说明找到了要更新的结点。接着将找到的结点中的数据替换成要更新的数据即可；</li><li>如果遍历结束还没找到对应编号的结点，说明链表中不存在这个结点；</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 修改节点信息,根据no编号来修改,即no编号不能改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">        <span class="comment">//定义一个辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//找到需要修改的节点,根据no编号</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">//表示当前到链表尾端</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;<span class="comment">//表示找到该节点了</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;<span class="comment">//根据flag可以判断是否找到要修改的节点</span></span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;没有找到编号%d的阶段,不能进行修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">    &#125;</span><br><span class="line">----------------- main()调用测试 ----------------------------------------</span><br><span class="line">  <span class="comment">//测试修改节点的代码</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟~~&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试修改后的&quot;</span>);</span><br><span class="line">        singleLinkedList.list();  </span><br></pre></td></tr></table></figure></li></ol><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><ol><li><p>思路分析:</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230323165525723.png" class="" title="image-20230323165525723"><ul><li>其实就是方法二中<code>实例场景示例图</code>的逆推</li><li>首先还是要创建一个头结点，然后拷贝一个头结点作为辅助变量，使用辅助变量来遍历整个链表；</li><li>如果 遍历到某个结点的编号与要查找的给定的编号相同，那么就找到了结点；</li><li>如果遍历结束还没找到，说明该编号不在链表的结点中。</li></ul></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//6. 删除节点1.head不能动,所以需要一个temp辅助节点找到待删除节点前的一个节点</span></span><br><span class="line">    <span class="comment">//         2.我们比较时,时temp.next.no和待删除节点的no比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明到了链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//表示找到了待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) temp.next=temp.next.next; <span class="comment">//如果找到,进行删除</span></span><br><span class="line">        <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>,no);</span><br><span class="line">    &#125;</span><br><span class="line">----------------- main()调用 ------------------------------</span><br><span class="line">   <span class="comment">//删除一个节点</span></span><br><span class="line">    singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">    singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">    singleLinkedList.list();</span><br></pre></td></tr></table></figure></li></ol><h4 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h4><ol><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.secondadd;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="comment">//先创建节点对象,一个节点就是一个节点英雄</span></span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">   <span class="comment">//创建链表对象</span></span><br><span class="line">   <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">   <span class="comment">//1. 不按顺序添加:方法一</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero4);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero3);</span></span><br><span class="line">   <span class="comment">//2. 添加方法二</span></span><br><span class="line">   singleLinkedList.addByOrder(hero1);</span><br><span class="line">   singleLinkedList.addByOrder(hero3);</span><br><span class="line">   singleLinkedList.addByOrder(hero2);</span><br><span class="line">   singleLinkedList.addByOrder(hero4);</span><br><span class="line">   singleLinkedList.addByOrder(hero4);</span><br><span class="line">   <span class="comment">//调用打印</span></span><br><span class="line">   singleLinkedList.list();</span><br><span class="line">   <span class="comment">//3. 测试修改节点的代码</span></span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟~~&quot;</span>);</span><br><span class="line">   singleLinkedList.update(newHeroNode);</span><br><span class="line">   System.out.println(<span class="string">&quot;测试修改后的&quot;</span>);</span><br><span class="line">   singleLinkedList.list();</span><br><span class="line">   <span class="comment">//4. 删除一个节点</span></span><br><span class="line">   singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">   singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">   singleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**-------下面 `面试题部分`方法可以放在这个地方进行运行 编写的是静态方法----------------*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> K)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedHead</span><span class="params">(HeroNode head)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span> &#123;&#125;</span><br><span class="line"><span class="comment">/**-------下面 `面试题部分`方法可以放在这个地方进行运行----------------*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一、定义一个HeroNode,每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.no = no;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line">   <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了显示方法,我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二、定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line"><span class="comment">//1. 先初始化一个头节点,头节点不要动,不存放具体的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 返回头节点,get方法  这个方法是配合下面面试题时使用,使外面也能获得私有变量</span></span><br><span class="line"><span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3. 添加节点到单链表后-----------------弃用的,用来对比`addByOrder()`</span></span><br><span class="line"><span class="comment">    * 思路:不考虑编号顺序,直接插入到链表最后</span></span><br><span class="line"><span class="comment">    * 1)找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">    * 2)将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">       <span class="comment">//因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="comment">//遍历链表,找到最后</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">//找到链表的最后:当next值为空,就是最后一位</span></span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//如果没有找到最后,就将temp向后移动,不然就原地踏步死循环了</span></span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当退出while循环的时候,temp就指向了链表的最后</span></span><br><span class="line">       <span class="comment">//将最后这个节点的next指向新的节点</span></span><br><span class="line">       temp.next = heroNode;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4. 添加节点到单链表后,按no排序</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">   <span class="comment">/*因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line"><span class="comment">      因为单链表,所以我们找的temp 必须为于添加位置的前一个节点,否则插入不了*/</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//flag标识添加的编号是否存在,默认为false</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明temp已经在链表的最后,就在链表插入(此时temp已经在链表尾部了)</span></span><br><span class="line">           <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) <span class="keyword">break</span>;<span class="comment">//说明位置已经找到,就在temp的后面插入</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode编号已经存在</span></span><br><span class="line">               flag = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;<span class="comment">//temp后移,直到找到符合上面条件为止</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了,不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//将heroNode插入到链表的temp后面</span></span><br><span class="line">           heroNode.next = temp.next;</span><br><span class="line">           temp.next = heroNode;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5. 修改节点信息,根据no编号来修改,即no编号不能改</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ;</span><br><span class="line">       <span class="comment">//定义一个辅助变量</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">//找到需要修改的节点,根据no编号</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">//表示当前到链表尾端</span></span><br><span class="line">           <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;<span class="comment">//表示找到该节点了</span></span><br><span class="line">               flag = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) &#123;<span class="comment">//根据flag可以判断是否找到要修改的节点</span></span><br><span class="line">           temp.name = newHeroNode.name;</span><br><span class="line">           temp.nickname = newHeroNode.nickname;</span><br><span class="line">       &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;没有找到编号%d的阶段,不能进行修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//6. 删除节点1.head不能动,所以需要一个temp辅助节点找到待删除节点前的一个节点</span></span><br><span class="line">   <span class="comment">//         2.我们比较时,时temp.next.no和待删除节点的no比较</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line"><span class="comment">//        if (head.next == null) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;链表为空&quot;);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;此处可以不加,与下面代码功能重复</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明到了链表的最后</span></span><br><span class="line">           <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">               <span class="comment">//表示找到了待删除节点的前一个节点temp</span></span><br><span class="line">               flag = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) temp.next = temp.next.next; <span class="comment">//如果找到,进行删除</span></span><br><span class="line">       <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>, no);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//7. 显示链表[遍历]</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//判断链表是否为空</span></span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//输出节点信息</span></span><br><span class="line">           System.out.println(temp);</span><br><span class="line">           <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="单链表-面试题"><a href="#单链表-面试题" class="headerlink" title="单链表 面试题"></a>单链表 面试题</h3><blockquote><p>单链表的常见面试题有如下:</p><p>1)求单链表中有效节点的个数</p><p>2)查找单链表中的倒数第k个结点 【新浪面试题】</p><p>3)单链表的反转【腾讯面试题，有点难度】</p><p>4)从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】</p><p>5)合并两个有序的单链表，合并之后的链表依然有序【课后练习.】</p><p>以下例子将在<code>2</code>部分的全部代码中实现,在上面代码中<code>已经预留位置</code></p></blockquote><h4 id="求单链表中有效节点的个数"><a href="#求单链表中有效节点的个数" class="headerlink" title="求单链表中有效节点的个数"></a>求单链表中有效节点的个数</h4><ol><li><p>就是直接遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 求单链表中有效节点的个数</span></span><br><span class="line"><span class="comment">    * 方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//空链表</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//声明一个累加器</span></span><br><span class="line">       <span class="comment">//定义一个辅助的变量,这里我们没有统计头节点(--&gt;head.next)</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;<span class="comment">//当当前节点 为空时退出累计遍历</span></span><br><span class="line">           length++;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> length;</span><br><span class="line">   &#125;;</span><br><span class="line">-----------------main()调用  ---------------------------</span><br><span class="line">System.out.println(<span class="string">&quot;有效的节点个数=&quot;</span> + getLength(singleLinkedList.getHead()));<span class="comment">//2</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="查找单链表中的倒数第k个结点-【新浪面试题】"><a href="#查找单链表中的倒数第k个结点-【新浪面试题】" class="headerlink" title="查找单链表中的倒数第k个结点 【新浪面试题】"></a>查找单链表中的倒数第k个结点 【新浪面试题】</h4><ol><li><p>思路分析:</p><blockquote><ul><li>1)编写一个方法，接收head节点，同时接收一个K</li><li>2)K表示是倒数第K个节点</li><li>3)先把链表从头到尾遍历，得到链表的总的长度 getLength</li><li>4)得到size 后，我们从链表的第一个开始遍历 (size-K)个，就可以得到</li><li>5)如果找到了，则返回该节点，否则返回null</li></ul></blockquote></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**2.查找单链表中的倒数第k个结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 要进行查找的单向链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> K 传入倒数第几位 数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该位置的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//空链表,无法找到</span></span><br><span class="line">        <span class="comment">//1. 获得链表的长度(总个数)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">        <span class="comment">//2. 做一个K的校验,明显K不能为负数以及大于总长度</span></span><br><span class="line">        <span class="keyword">if</span> (K &lt;= <span class="number">0</span> || K &gt; size) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//3. 定义给辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//4. 遍历 倒数第K个节点 就是`size-K`的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (size - K); i++) &#123;</span><br><span class="line">            cur = cur.next; <span class="comment">//cur后移到符合条件的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">-----------------main()调用  ---------------------------</span><br><span class="line"> <span class="comment">//测试一下看看是否得到了倒数第K个节点</span></span><br><span class="line"> <span class="type">HeroNode</span> <span class="variable">res</span> <span class="operator">=</span> findLastIndexNode(singleLinkedList.getHead(), <span class="number">2</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br></pre></td></tr></table></figure></li></ol><h4 id="单链表的反转【腾讯面试题，有点难度】"><a href="#单链表的反转【腾讯面试题，有点难度】" class="headerlink" title="单链表的反转【腾讯面试题，有点难度】"></a>单链表的反转【腾讯面试题，有点难度】</h4><ol><li><p>解决这个问题的核心就是<code>头插法</code></p><ul><li>首先创建一个临时头结点用于记录反转过程中的链表；</li><li>遍历单链表，每遍历到一个有效结点，就让该有效结点指向临时头结点指向的结点；</li><li>临时头结点再指向该有效结点，</li><li>原单链表遍历结束之后，再让原头结点指向临时头结点指向的结点。</li></ul></li><li><p>图片示例</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324085311268.png" class="" title="image-20230324085311268"></li><li><p>具体举例图解</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324085340478.png" class="" title="image-20230324085340478"></li><li><p>代码实现</p><ul><li><p>实现方法一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 3.单链表的反转【腾讯面试题，有点难度】</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> head 传入需要进行反转的单链表</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedHead</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">           <span class="comment">//1. 当链表为空或者只有一个节点时候,直接返回,无需反转</span></span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">           <span class="comment">//2. 定义一个辅助的指针遍历,帮助我们遍历原来的链表</span></span><br><span class="line">           <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">           <span class="comment">//3. 定义一个next,辅助变量,来指向当前节点[cur]的下一个节点,用来进行位置互换</span></span><br><span class="line">           <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//4. 初始化一个新的头节点,用来暂时存放反转链表</span></span><br><span class="line">           <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">           <span class="comment">//5. 遍历原来的链表,每遍历一个节点,就将其取出,并放在新的链表reverseHead的最前端</span></span><br><span class="line">           <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;<span class="comment">//当当前节点 为空时退出累计遍历</span></span><br><span class="line">               next = cur.next; <span class="comment">//先暂时保存当前节点的下一个节点,后面换完位置后需要复原cur的下一位,否则无法遍历</span></span><br><span class="line">               cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">               reverseHead.next = cur;<span class="comment">//将cur链接到新的链表上</span></span><br><span class="line">               cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//遍历结束,将head.next指向reverseHead.next 接管链表,实现单链表的反转</span></span><br><span class="line">           head.next = reverseHead.next;</span><br><span class="line">       &#125;</span><br><span class="line">   -----------------main()调用  ---------------------------</span><br><span class="line">      <span class="comment">//7. 测试一下单链表的反转功能</span></span><br><span class="line">   System.out.println(<span class="string">&quot;原来链表的情况~~&quot;</span>);</span><br><span class="line">   singleLinkedList.list();</span><br><span class="line">   System.out.println(<span class="string">&quot;反转单链表~~&quot;</span>);</span><br><span class="line">   reverseLinkedHead(singleLinkedList.getHead());</span><br><span class="line">   singleLinkedList.list();</span><br></pre></td></tr></table></figure></li><li><p>实现方法二(只是写法改变,但代码显得更容易理解)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SingleLinkedList <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">SingleLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">    <span class="comment">// 遍历待反转的链表，将结点依次添加到新链表</span></span><br><span class="line">   <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (tmp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        linkedList.addFirst(tmp.next.item);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addFirst</span><span class="params">(Integer item)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(item, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// tmp 指向头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    newNode.next = tmp.next;</span><br><span class="line">    tmp.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="从尾到头打印单链表"><a href="#从尾到头打印单链表" class="headerlink" title="从尾到头打印单链表"></a>从尾到头打印单链表</h4><ol><li><p>【百度面试题，要求方式1：反向遍历(上一个问题解决) 。 方式2：Stack栈   方法3: 递归】</p></li><li><p><code>栈方法</code></p></li><li><p>思路分析图解</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324085606977.png" class="" title="image-20230324085606977"></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 4. 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> head 要传入的链表头</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">//空链表 不能打印</span></span><br><span class="line">     <span class="comment">//创建一个栈,将各个节点压入栈</span></span><br><span class="line">     Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt;();</span><br><span class="line">     <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">     <span class="comment">//将链表所有节点压入栈</span></span><br><span class="line">     <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">         stack.push(cur);</span><br><span class="line">         cur = cur.next;<span class="comment">//cur后移,这样就可以压入下一个节点</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//将栈中节点取出打印.利用其先进后出特点,实现逆序da&#x27;yin</span></span><br><span class="line">     <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         System.out.println(stack.pop());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> -----------------main()调用  ---------------------------</span><br><span class="line"><span class="comment">//8.测试逆序打印单链表, 没有改变链表的结构~~</span></span><br><span class="line">System.out.println(<span class="string">&quot;测试逆序打印单链表, 没有改变链表的结构~~&quot;</span>);</span><br><span class="line">reversePrint(singleLinkedList.getHead());</span><br></pre></td></tr></table></figure></li><li><p><code>递归方式</code></p></li><li><p>图例</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324085746357.png" class="" title="image-20230324085746357"></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归打印结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> [node] 链表的第一个结点，即 head.next</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printReverse_3</span><span class="params">(HeroNode node)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里一定要先递归调用再打印</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        printReverse_3(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="合并两个有序的单链表，合并之后的链表依然有序"><a href="#合并两个有序的单链表，合并之后的链表依然有序" class="headerlink" title="合并两个有序的单链表，合并之后的链表依然有序"></a>合并两个有序的单链表，合并之后的链表依然有序</h4><ol><li><p>思路解析</p><ul><li><p>如果传入的节点1为空了(即已经递归到链表尾或者是空链表),返回节点2,反之亦然(同时return会结束该递归函数(但是递归函数结束后接着return,所以整个递归函数将会停止)并返回)。</p></li><li><p>判断no是否重复,如果重复就重新递归传入链表下一级<code>head2.next</code>,不重复就传入<code>head2</code></p></li><li><p>递归其实都是在进行对于<code>head.next</code>的赋值,直到传入节点为空(符合前面两个判断条件),开始向外<code>return</code>,此时逐层给<code>head.next</code>赋值,最后会返回到最外层函数返回值处,就是合并后的链表</p></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 合并两个单链表静态函数</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> head1 传入第一个链表头节点</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> head2 传入第二个链表头节点</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 返回合并后的链表</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">mergeLinkedList</span><span class="params">(HeroNode head1, HeroNode head2)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (head1 == <span class="literal">null</span>) <span class="keyword">return</span> head2; <span class="comment">//此处是递归,不能按head.next==null进行判断,否则会造成数据丢失</span></span><br><span class="line">          <span class="keyword">if</span> (head2 == <span class="literal">null</span>)  <span class="keyword">return</span> head1;     </span><br><span class="line">          <span class="keyword">if</span> (head1.no &lt;= head2.no) &#123;</span><br><span class="line">              <span class="comment">//如果不加这个判断,如果两者的no相同,将会导致出现重复的数据(如两个),判断后进入递归</span></span><br><span class="line">              <span class="comment">//打印代码 System.out.println(&quot;head:&quot;+head+&quot;,head.next:&quot;+head.next);</span></span><br><span class="line">              <span class="comment">//打印结果 headHeroNode:[no=0,name=,nickname=],head.nextHeroNode:[no=0,name=,nickname=]</span></span><br><span class="line">              head1.next = (head2.no != head1.no) ? mergeLinkedList(head1.next, head2)</span><br><span class="line">                  : mergeLinkedList(head1.next, head2.next);</span><br><span class="line">  <span class="comment">//            head1.next= mergeLinkedList(head1.next, head2);  犯下的错误,导致数据重复</span></span><br><span class="line">              <span class="keyword">return</span> head1;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              head2.next = mergeLinkedList(head1, head2.next);</span><br><span class="line">              <span class="keyword">return</span> head2;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 遍历打印静态链表</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> head 传入打印的链表头节点</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticList</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">          <span class="comment">//判断链表是否为空</span></span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">          <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">          System.out.println(<span class="string">&quot;head&quot;</span> + head + <span class="string">&quot;,head.next&quot;</span> + head.next);</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">//输出节点信息</span></span><br><span class="line">              System.out.println(temp);</span><br><span class="line">              <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  -------------------  main()调用 --------------------------------</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;努力学习的汪&quot;</span>, <span class="string">&quot;好学生&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">7</span>, <span class="string">&quot;离婚且带娃&quot;</span>, <span class="string">&quot;不是我&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;你听我狡辩&quot;</span>, <span class="string">&quot;口头禅&quot;</span>);</span><br><span class="line">        <span class="comment">//创建链表对象</span></span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">    <span class="comment">//2. 添加方法</span></span><br><span class="line">    singleLinkedList.addByOrder(hero1);</span><br><span class="line">    singleLinkedList.addByOrder(hero3);</span><br><span class="line">    singleLinkedList.addByOrder(hero4);</span><br><span class="line">    singleLinkedList.addByOrder(hero7);</span><br><span class="line">    singleLinkedList.list();</span><br><span class="line">    System.out.println(<span class="string">&quot;两个链表分界线&quot;</span>);</span><br><span class="line">    <span class="comment">//-----------课后作业:第二个链表-----------------------</span></span><br><span class="line">    singleLinkedList1.addByOrder(hero2);</span><br><span class="line">    singleLinkedList1.addByOrder(hero5);</span><br><span class="line">    singleLinkedList1.addByOrder(hero6);</span><br><span class="line">    singleLinkedList1.addByOrder(hero8);</span><br><span class="line">    singleLinkedList1.list();</span><br><span class="line">    System.out.println(<span class="string">&quot;合并两个链表&quot;</span>);</span><br><span class="line">    staticList(mergeLinkedList(singleLinkedList.getHead(), singleLinkedList1.getHead()));</span><br></pre></td></tr></table></figure></li></ol><h3 id="双向链表与其实例"><a href="#双向链表与其实例" class="headerlink" title="双向链表与其实例"></a>双向链表与其实例</h3><ol><li><p>双向链表实现实际上对比单向链表多了一个<code>pre</code>属性,大部分功能相似</p></li><li><p>使用双向链表实现水浒传英雄增删改查思路图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324090248833.png" class="" title="image-20230324090248833"></li><li><p>删除部分代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 5. 从双向链表中删除一个节点</span></span><br><span class="line"><span class="comment">      * 说明:</span></span><br><span class="line"><span class="comment">      * 1.对于双向链表,我们可以直接找到要删除的这个节点</span></span><br><span class="line"><span class="comment">      * 2.找到后,自我删除即可</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;链表为空,无法删除&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;<span class="comment">//辅助遍历(指针)</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标识是否找到待删除节点</span></span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//已经到了链表最后</span></span><br><span class="line">             <span class="keyword">if</span> (temp.no == no) &#123; <span class="comment">//找到待删除的节点</span></span><br><span class="line">                 flag = <span class="literal">true</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             temp = temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">             temp.pre.next = temp.next;<span class="comment">//将下一个节点地址赋值给上一个节点的`next`</span></span><br><span class="line">             <span class="comment">//如果不加判断,可能当前节点是最后一个,导致`temp.next.pre`会出现空指针异常</span></span><br><span class="line">             <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) temp.next.pre = temp.pre;<span class="comment">//将下一个节点的上一个(pre)赋值为当前节点的上一个(pre)</span></span><br><span class="line">         &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>, no);</span><br><span class="line">   </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>全部代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.doublelinked;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">hero5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">5</span>, <span class="string">&quot;666&quot;</span>, <span class="string">&quot;666&quot;</span>);</span><br><span class="line">          <span class="comment">//创建链表对象</span></span><br><span class="line">          <span class="type">DoubleLinkedList</span> <span class="variable">doubleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">          <span class="comment">//1.直接添加到链表尾部</span></span><br><span class="line">          doubleLinkedList.add(hero1);</span><br><span class="line">          doubleLinkedList.add(hero2);</span><br><span class="line">          doubleLinkedList.add(hero3);</span><br><span class="line">          doubleLinkedList.add(hero4);</span><br><span class="line">          doubleLinkedList.list();</span><br><span class="line">          <span class="comment">//修改测试</span></span><br><span class="line">          System.out.println(<span class="string">&quot;测试修改林冲&quot;</span>);</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">4</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;零充&quot;</span>);</span><br><span class="line">          doubleLinkedList.update(newHeroNode);</span><br><span class="line">          doubleLinkedList.list();</span><br><span class="line">          <span class="comment">//删除测试</span></span><br><span class="line">          System.out.println(<span class="string">&quot;测试删除吴用&quot;</span>);</span><br><span class="line">          doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">          doubleLinkedList.list();</span><br><span class="line">          <span class="comment">//测试插入添加</span></span><br><span class="line">          <span class="comment">//1.直接添加到链表尾部</span></span><br><span class="line">          System.out.println(<span class="string">&quot;测试插入添加 &quot;</span>);</span><br><span class="line">          doubleLinkedList.addByOrder(hero5);</span><br><span class="line">          doubleLinkedList.addByOrder(hero3);</span><br><span class="line">          doubleLinkedList.list();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">      <span class="comment">//1. 先初始化一个头节点,头节点不要动,不存放具体的数据</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">DoubleHeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 返回头节点,get方法</span></span><br><span class="line">      <span class="keyword">public</span> DoubleHeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 添加一个节点节点到双向链表的最后</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(DoubleHeroNode heroNode)</span> &#123;</span><br><span class="line">          <span class="comment">//因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">          <span class="comment">//遍历链表,找到最后</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="comment">//找到链表的最后:当next值为空,就是最后一位</span></span><br><span class="line">              <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">//如果没有找到最后,就将temp向后移动,不然就原地踏步死循环了</span></span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//当退出while循环的时候,temp就指向了链表的最后</span></span><br><span class="line">          <span class="comment">//形成一个双向链表</span></span><br><span class="line">          temp.next = heroNode;</span><br><span class="line">          heroNode.pre = temp;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.1 按照no进行对双向链表的插入,课堂练习题</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(DoubleHeroNode heroNode)</span> &#123;</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;<span class="comment">//需要找到要添加位置的前一个节点</span></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明已经遍历到链表最后</span></span><br><span class="line">              <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) <span class="keyword">break</span>;<span class="comment">//说明已经找到,就在temp后面插入</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明已经存在重复no</span></span><br><span class="line">                  flag = <span class="literal">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag) System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了,不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              heroNode.next = temp.next; <span class="comment">//将temp的下next赋值到要插入的节点的next</span></span><br><span class="line">              heroNode.pre = temp;  <span class="comment">//将temp作为heroNode的pre(上一位)</span></span><br><span class="line">              temp.next = heroNode; <span class="comment">//在找到的位置后面插入heroNode ,并且这里不用判断非空</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4. 修改节点信息,</span></span><br><span class="line">      <span class="comment">//可以看到双向链表的节点内容修改与单向链表一样,只是节点类型改变</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(DoubleHeroNode newHeroNode)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">//找到需要修改的节点,根据no编号</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">//表示当前到链表尾端</span></span><br><span class="line">              <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;<span class="comment">//表示找到该节点了</span></span><br><span class="line">                  flag = <span class="literal">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;<span class="comment">//根据flag可以判断是否找到要修改的节点</span></span><br><span class="line">              temp.name = newHeroNode.name;</span><br><span class="line">              temp.nickname = newHeroNode.nickname;</span><br><span class="line">          &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;没有找到编号%d的阶段,不能进行修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 5. 从双向链表中删除一个节点</span></span><br><span class="line"><span class="comment">       * 说明:</span></span><br><span class="line"><span class="comment">       * 1.对于双向链表,我们可以直接找到要删除的这个节点</span></span><br><span class="line"><span class="comment">       * 2.找到后,自我删除即可</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;链表为空,无法删除&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;<span class="comment">//辅助遍历(指针)</span></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标识是否找到待删除节点</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//已经到了链表最后</span></span><br><span class="line">              <span class="keyword">if</span> (temp.no == no) &#123; <span class="comment">//找到待删除的节点</span></span><br><span class="line">                  flag = <span class="literal">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              temp = temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">              temp.pre.next = temp.next;<span class="comment">//将下一个节点地址赋值给上一个节点的`next`</span></span><br><span class="line">              <span class="comment">//如果不加判断,可能当前节点是最后一个,导致`temp.next.pre`会出现空指针异常</span></span><br><span class="line">              <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) temp.next.pre = temp.pre;<span class="comment">//将下一个节点的上一个(pre)赋值为当前节点的上一个(pre)</span></span><br><span class="line">          &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>, no);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//7. 显示链表[遍历]</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">//判断链表是否为空</span></span><br><span class="line">          <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">          <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">//输出节点信息</span></span><br><span class="line">              System.out.println(temp);</span><br><span class="line">              <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">              temp = temp.next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//一、定义一个HeroNode,每个HeroNode对象就是一个节点</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">DoubleHeroNode</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">      <span class="keyword">public</span> String name;</span><br><span class="line">      <span class="keyword">public</span> String nickname;</span><br><span class="line">      <span class="keyword">public</span> DoubleHeroNode next;<span class="comment">//指向下一个节点,默认为null</span></span><br><span class="line">      <span class="keyword">public</span> DoubleHeroNode pre;<span class="comment">//指向前一个节点,默认为null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//构造器</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">DoubleHeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.no = no;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">          <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//为了显示方法,我们重新toString</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="单向与双向链表对比"><a href="#单向与双向链表对比" class="headerlink" title="单向与双向链表对比"></a>单向与双向链表对比</h3><ol><li><p>管理单向链表相较于双向链表的缺点分析</p><ul><li>① 单链表只有一个指向下一结点的指针，也就是只能next; ② 双链表除了有一个指向下一结点的指针外，还有一个指向前一结点的指针，可以通过prev()快速找到前一结点，顾名思义，单链表只能单向读取</li><li>单向链表不能自我删除，需要靠辅助节点 ，而双向链表则可以自我删除，所以前面我们单链表删除时节点，总是找到 temp,temp 是待删除节点的前一个节点,双向链表则是可以直接将temp指向要删除的节点</li></ul></li><li><p>双链表具有以下优点:</p><ul><li>删除单链表中的某个结点时，一定要得到待删除结点的前驱，得到该前驱有两种方法，第一种方法是在定位待删除结点的同时一路保存当前结点的前驱。第二种方法是在定位到待删除结点之后，重新从单链表表头开始来定位前驱。尽管通常会采用方法一。但其实这两种方法的效率是一样</li><li>查找时也一样，我们可以借用二分法的思路，从head（首节点）向后查找操作和last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍</li></ul></li><li><p><code>面试官</code>：从你的描述来看，双链表的在查找、删除的时候可以利用二分法的思想去实现,但是为什么目前市场应用上<code>单链表的应用要比双链表的应用要广泛</code>的多呢?</p><ul><li>从存储结构来看，每个双链表的节点要比单链表的节点多一个指针，而长度为n就需要 n*length（这个指针的length在32位系统中是4字节，在64位系统中是8个字节） 的空间，这在一些追求时间效率不高应用下并不适应，因为它占用空间大于单链表所占用的空间；这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。</li></ul></li><li><p>结构对比图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324090646504.png" class="" title="image-20230324090646504"></li></ol><h3 id="单链表之约瑟夫问题"><a href="#单链表之约瑟夫问题" class="headerlink" title="单链表之约瑟夫问题"></a>单链表之<code>约瑟夫问题</code></h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol><li><p><code>约瑟夫</code>（ <em>Josephu</em> ） 问题是一个非常著名的有趣的题目。问题具体描述如下：</p><blockquote><p>设编号分别为1、2、3… n 的 n 个人围坐一圈，约定编号为 k（1≤k≤n）的人从 1 开始报数，数到 m 的那个人出列。出列的人的下一位又从 1 开始报数，数到 m 的那个人继续出列。以此类推，直到所有人都出列为止，由此产生一个出队编号的序列，这个序列也就是约瑟夫问题的解。</p></blockquote></li><li><p>下面将用一个动图来描述一下这个问题</p><blockquote><p>假设有 4 个人围坐一圈，约定编号为 1 的人开始报数，数到 3 的那个出列。最后产生的出队编号的序列将会是：3、2、4、1。</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324090844251.png" class="" title="image-20230324090844251"></blockquote></li></ol><h4 id="思路实现"><a href="#思路实现" class="headerlink" title="思路实现"></a>思路实现</h4><ol><li><p>用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p></li><li><p>约瑟夫问题-创建环形链表的思路图解</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324090951439.png" class="" title="image-20230324090951439"></li><li><p>约瑟夫问题-小孩出圈的思路分析图</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324091007521.png" class="" title="image-20230324091007521"></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.josepfu;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Josepfu</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">int</span> NUM=<span class="number">5</span>;<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">          <span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">          <span class="type">CircleSingleLinkedList</span> <span class="variable">circleSingleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleSingleLinkedList</span>();</span><br><span class="line">          circleSingleLinkedList.addBoy(NUM);</span><br><span class="line">          circleSingleLinkedList.showBoy();</span><br><span class="line">          <span class="comment">//测试一把小孩出圈是否正确</span></span><br><span class="line">          circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, NUM); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二、创建一个环形的单向链表</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span> &#123;</span><br><span class="line">      <span class="comment">//1. 创建一个first节点,当前没有编号</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 添加小孩节点,构建成一个环形的链表</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span> &#123;</span><br><span class="line">          <span class="comment">//nums做一个数据校验</span></span><br><span class="line">          <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;nums的值不正确&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//辅助指针,帮助构建环形链表</span></span><br><span class="line">          <span class="comment">//使用for来创建我们的环形链表</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums; i++) &#123;<span class="comment">//i从1开始,才能得到编号与数字顺序一样的no;</span></span><br><span class="line">              <span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">              <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">              <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; <span class="comment">//如果fori从0开始遍历,这里也要改为i==0,否则下面 `curBoy.setNext(boy);`将空指针异常</span></span><br><span class="line">                  first = boy;</span><br><span class="line">                  first.setNext(first); <span class="comment">//构成环,即只有一个时自己指向自己</span></span><br><span class="line">                  curBoy = first;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  boy.setNext(first); <span class="comment">//将当前次循环的next指向第一个节点形成环</span></span><br><span class="line">                  curBoy.setNext(boy);<span class="comment">//此处curBoy标记的是上一次循环的boy 如`i==2`--&gt;curBoy==first、`i==3`--&gt;curBoy==boy(第二个)</span></span><br><span class="line">                  curBoy = boy;  <span class="comment">//这一步是移动当前curBoy位置到boy,保存当前boy 用作在下轮循环中指定当前boy的next</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 遍历当前环形链表</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;没有任何小孩~~~~&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              System.out.printf(<span class="string">&quot;小孩编号%d\n&quot;</span>, curBoy.getNo());</span><br><span class="line">              <span class="keyword">if</span> (curBoy.getNext() == first) <span class="keyword">break</span>;</span><br><span class="line">              curBoy = curBoy.getNext();<span class="comment">//curBoy后移</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * //4. 根据用户输入,计算小孩出圈的顺序</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> startNo  开始的位置</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> countNum 每次循环的数字</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> nums     单纯用来校验循环次数是否多于总长度</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo, <span class="type">int</span> countNum, <span class="type">int</span> nums)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (first == <span class="literal">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;参数输入有误,请重新输入&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//①创建一个辅助指针,帮助完成小孩出圈</span></span><br><span class="line">          <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">          <span class="comment">//②将辅助指针事先指向环形列表的最后这个节点(即next指向first)</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helper.getNext() == first) <span class="keyword">break</span>;<span class="comment">//说明helper指向最后的小孩节点</span></span><br><span class="line">              helper = helper.getNext();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//③小孩报数前,先让first和helper移动K-1次(如果我是从3开始,我需要事先指向3的位置)</span></span><br><span class="line">          <span class="comment">//为什么是K-1次--&gt;因为循环i是从0开始的</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">              first = first.getNext();</span><br><span class="line">              helper = helper.getNext();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//④出圈删除:当小孩报数时,让first和helper指针同时移动m-1次,然后出圈</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helper == first) <span class="keyword">break</span>; <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">              <span class="comment">//让first和helper指针同时移动countNum-1次</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                  first = first.getNext();</span><br><span class="line">                  helper = helper.getNext();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//出了for循环后,此时first指向的节点就是要出圈的小孩节点</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;小孩%d出圈\n&quot;</span>, first.getNo());</span><br><span class="line">              <span class="comment">//此时将first指向的小孩节点出圈</span></span><br><span class="line">              first = first.getNext();</span><br><span class="line">             <span class="comment">//注意:此处用的时setNext--&gt;这步就是删除操作,原来的first指向的节点没有任何引用的时候,就会被回收</span></span><br><span class="line">              helper.setNext(first);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号%d\n&quot;</span>, first.getNo());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//一、创建一个Boy类,表示一个节点</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">//编号</span></span><br><span class="line">      <span class="keyword">private</span> Boy next; <span class="comment">//指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.no = no;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> no;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.no = no;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.next = next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="思路改进与代码实现"><a href="#思路改进与代码实现" class="headerlink" title="思路改进与代码实现"></a>思路改进与代码实现</h4><p>将该问题解决思想带入 实现水浒传英雄</p><ol><li><p>思路解析:</p><blockquote><ol><li><p>首先要确定解决问题的核心思想：<code>使用一个不带头结点的循环(环形)链表来处理该问题</code>。</p></li><li><p>假设每个结点代表一个人，那么一个由 n 个结点组成的循环链表就相当于是 n 个人围成的一个圈。那么约瑟夫问题以环形链表的形式来描述就是如下情景：</p></li></ol><blockquote><p>首先使用 n 个结点构成一个单向循环链表，然后由第 k 个结点起从 1 开始计数，当计到 m 时，从链表中删除对应结点；接着从被删除结点的下一个结点开始从 1 计数，当计到 m 时，继续从链表中删除。依次循环往复，直到链表中的所有结点都被删除为止。</p></blockquote><ol start="3"><li>那么对于这个单向循环链表形式下的约瑟夫问题，我们如何解决呢？</li></ol><ul><li><p>我们可以引入一个辅助指针 helperNode，这个指针总是指向待删除结点的前一个结点。为什么这个辅助指针要指向待删除结点的前一个结点，而不是指向自身呢？</p></li><li><p>因为我们的目的是要删除当前计数为 m 的结点，但是受限于单向链表的特性（如果要删除单链表的某个结点，必须要知道该结点的前一个结点），我们无法让结点自己删除自己。鉴于这个特性，我们必须要引入一个辅助指针来记录当前正在计数的结点的前一个结点，这样才能符合删除条件的结点从链表中删除。</p></li></ul></blockquote></li><li><p>引入这个辅助指针之后，具体的操作思路如下:</p><blockquote><ol><li>每一轮计数开始时，总让辅助指针 helperNode 初始指向本轮第一个计数的结点；</li><li>从第一个计数的结点开始计数至 m，实际上是向后移动了 m-1 个结点。由于辅助指针总是指向待删除结点的前一个结点，因此让需要让辅助指从第一个计数结点后移 m-2 个结点；</li><li>辅助指针移动到待删除结点的前一个结点之后，只需要让辅助指针指向待删除的结点的下一个结点即可完成删除操作；</li><li>依次循环往复，直至只剩最后一个结点；</li><li>对于环形链表判断是否只有最后一个结点，只需要判断辅助指针指向的结点是否是辅助指针指向的结点的下一个结点即可。</li></ol></blockquote></li><li><p>上面的思路可以用下面一个动图来描述:</p><img src="/2018/03/24/MD-Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230324091251984.png" class="" title="image-20230324091251984"></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.doublelinked;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程外思路实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造测试数据</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;公孙胜&quot;</span>, <span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;码农&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;努力学习的汪&quot;</span>, <span class="string">&quot;学习狗&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============向环形链表中插入结点==================&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">first</span> <span class="operator">=</span> insertCircleList(<span class="literal">null</span>, node_1);</span><br><span class="line">        first = insertCircleList(first, node_2);</span><br><span class="line">        first = insertCircleList(first, node_3);</span><br><span class="line">        first = insertCircleList(first, node_4);</span><br><span class="line">        first = insertCircleList(first, node_5);</span><br><span class="line">        first = insertCircleList(first, node_6);</span><br><span class="line">        showList(first);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============约瑟夫游戏开始===============&quot;</span>);</span><br><span class="line">        <span class="comment">// 从第 1 个结点开始计数，每次计 3 个数。</span></span><br><span class="line">        josepfuGame(first, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 1. 约瑟夫游戏开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> [first, k, m]   头节点,从第 k 个人开始数，每次数 m 个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">josepfuGame</span><span class="params">(HeroNode first, <span class="type">int</span> k, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">helperNode</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="comment">// 首先要移动到第 k 个结点，此时辅助指针初始指向第一个计数的结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            helperNode = helperNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (helperNode.next.getNo() != helperNode.getNo()) &#123;</span><br><span class="line">            <span class="comment">// 报数， m 个数也就是相当于向后移动 m-1 次，也就是要把第 m-1 个结点去掉</span></span><br><span class="line">            <span class="comment">// 由于单链表的特点，要去掉第 m-1 个结点，肯定是要让指针前一个结点，即第(m-2)个结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m - <span class="number">2</span>; j++) &#123;  <span class="comment">// 让指针后移 m-2 个结点</span></span><br><span class="line">                helperNode = helperNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(helperNode.next + <span class="string">&quot;退出链表了!&quot;</span>);</span><br><span class="line">            <span class="comment">// 删除结点</span></span><br><span class="line">            helperNode.next = helperNode.next.next;</span><br><span class="line">            <span class="comment">// 因为下一轮要从刚刚去掉的结点的后面一个结点开始计数了，所以需要让辅助指针初始指向下一轮第一个计数的结点</span></span><br><span class="line">            helperNode = helperNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(helperNode + <span class="string">&quot;退出链表了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 2. 插入结点到环形链表中，用于构造环形链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">insertCircleList</span><span class="params">(HeroNode first, HeroNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是不是为空，如果为空，就直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = node;</span><br><span class="line">            <span class="comment">// 因为要环形链表，而且只有一个结点，所以要我指向我自己</span></span><br><span class="line">            first.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果环形链表不为空</span></span><br><span class="line">            <span class="type">HeroNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> first;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果到了环形链表的最后一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (tempNode.next.getNo() == first.getNo()) &#123;</span><br><span class="line">                    tempNode.next = node;</span><br><span class="line">                    <span class="comment">// 因为是环形链表，所以最后一个结点还要指向第一个结点</span></span><br><span class="line">                    node.next = first;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tempNode = tempNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 3. 打印单向环形链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showList</span><span class="params">(HeroNode first)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempNode.next.getNo() == first.getNo()) &#123;</span><br><span class="line">                System.out.println(tempNode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(tempNode);</span><br><span class="line">            tempNode = tempNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;             <span class="comment">// 本节点数据</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;       <span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方法,我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickName + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装nginx</title>
      <link href="/2018/03/14/MD-CentOS7/centos7%E5%AE%89%E8%A3%85nginx/"/>
      <url>/2018/03/14/MD-CentOS7/centos7%E5%AE%89%E8%A3%85nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="下载nginx安装包"><a href="#下载nginx安装包" class="headerlink" title="下载nginx安装包"></a>下载nginx安装包</h2><p>进入官网下载页面，建议下载稳定版本</p><p><a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p><p>下载完成后上传到centos</p><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>安装依赖包</p><p>由于nginx是基于c语言开发的，所以需要安装c语言的编译环境，及正则表达式库等第三方依赖库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><p>解压nginx压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.22.1.tar.gz</span><br></pre></td></tr></table></figure><p>配置nginx编译环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.22.1</span><br><span class="line">./configure --prefix=/opt/moudle/nginx</span><br></pre></td></tr></table></figure><p><code>说明</code>: –prefix 指定的目录，就是我们安装Nginx的目录。</p><p>编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看版本</span></span><br><span class="line">./nginx -v</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查配置文件，修改了nginx.conf核心配置文件之后，在启动Nginx服务之前，可以先检查一下conf/nginx.conf文件配置的是否有错误，命令如下：</span></span><br><span class="line">./nginx -t</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">./nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动之后，我们可以通过ps -ef指令来查看nginx的进程是否存在。</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止</span></span><br><span class="line">./nginx -s stop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新加载，当修改了Nginx配置文件后，需要重新加载才能生效，可以使用下面命令重新加载配置文件：</span></span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="nginx-conf配置"><a href="#nginx-conf配置" class="headerlink" title="nginx.conf配置"></a>nginx.conf配置</h2><h3 id="配置静态网页"><a href="#配置静态网页" class="headerlink" title="配置静态网页"></a>配置静态网页</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">           </span><br><span class="line">            root   /opt/moudle/hexo-blog/public; #服务器上存放静态网页的目录</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Hexo</title>
      <link href="/2018/03/13/MD-Hexo/%E5%AE%89%E8%A3%85Hexo/"/>
      <url>/2018/03/13/MD-Hexo/%E5%AE%89%E8%A3%85Hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，然后<code>cd</code>到这个文件夹下，打开命令终端</p><h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>依旧用<code>hexo -v</code>查看一下版本</p><p>至此就全部安装完了。</p><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p><code>注意</code>,这里的命令都是作用在刚刚创建的Blog文件夹中。</p><p>然后cd到blog目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p>打开hexo的服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>在浏览器输入localhost:4000就可以看到你生成的博客了。</p><h2 id="Hexo-必装插件"><a href="#Hexo-必装插件" class="headerlink" title="Hexo 必装插件"></a>Hexo 必装插件</h2><h3 id="Hexo-asset-img"><a href="#Hexo-asset-img" class="headerlink" title="Hexo-asset-img"></a>Hexo-asset-img</h3><p>自动为文章中的图片提供绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><p>设置 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>比如新建一片博客名为 hexo-plugin，那么在创建文章 md 文件的同时会创建一个 hexo-plugin 的目录，文章对应的图片放入这个目录就行。</p><p>Typora 可以将图像设为 <code>$&#123;filename&#125;</code> 便可自动适配</p><h3 id="hexo-generator-search"><a href="#hexo-generator-search" class="headerlink" title="hexo-generator-search"></a>hexo-generator-search</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>配置根目录下的 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span> <span class="string">./search.xml</span></span><br></pre></td></tr></table></figure><p>最后需要导入搜索的模板文件 search.xml 文件到主题文件中，这个文件可以去 <a href="https://github.com/wzpan/hexo-generator-search">https://github.com/wzpan/hexo-generator-search</a> 下载，也可以在刚刚安装的依赖包中找到，具体地址为 node_modules/hexo-generator-search/demo_output/search.xml</p><p>修改 主題配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br></pre></td></tr></table></figure><h2 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h2><h3 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h3><p>一款很精致简单，但功能强大的主题。</p><p>主要有以下特点：</p><ol><li>Material Design 设计，简单漂亮，文章内容美观易读；</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现；</li><li>功能多，支持友链、评论模块、文章统计、音乐播放、视频播放等。</li></ol><ul><li>Github 地址：**<a href="https://link.zhihu.com/?target=https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a>**</li><li>安装教程：<a href="https://link.zhihu.com/?target=https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></li></ul><h2 id="hexo部署在github"><a href="#hexo部署在github" class="headerlink" title="hexo部署在github"></a>hexo部署在github</h2><h3 id="在github上创建项目"><a href="#在github上创建项目" class="headerlink" title="在github上创建项目"></a>在github上创建项目</h3><p>新建一个项目，然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。</p><img src="/2018/03/13/MD-Hexo/%E5%AE%89%E8%A3%85Hexo/image-20230312220906008.png" class="" title="image-20230312220906008"><p>然后项目就建成了</p><h3 id="配置根目录下的-config-yml"><a href="#配置根目录下的-config-yml" class="headerlink" title="配置根目录下的 _config.yml"></a>配置根目录下的 <code>_config.yml</code></h3><p>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:lijianjun821/lijianjun821.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>repository修改为你自己的github项目地址。</p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>首先在博客根目录下右键打开git bash，安装一个扩展</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><p>生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>然后输入hexo s可以本地预览效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>最后输入hexo d上传到github上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时打开你的github.io主页就能看到发布的文章啦。</p><p><a href="https://lijianjun821.github.io/">https://lijianjun821.github.io/</a></p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>1.首先解析域名,添加两条解析记录</p><img src="/2018/03/13/MD-Hexo/%E5%AE%89%E8%A3%85Hexo/image-20230312223119954.png" class="" title="image-20230312223119954"><p>2.打开你本地博客/source目录，新建CNAME文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行hexo g、hexo d上传到github</p><p>3.使用域名<code>jianjunw.com</code>访问bolg</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac 安装 nodejs</title>
      <link href="/2018/03/12/MD-Mac/mac%20%E5%AE%89%E8%A3%85%20nodejs/"/>
      <url>/2018/03/12/MD-Mac/mac%20%E5%AE%89%E8%A3%85%20nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h2><p>可参考官方最新安装命令</p><p><a href="https://github.com/nvm-sh/nvm#install-script">https://github.com/nvm-sh/nvm#install-script</a></p><h3 id="Install-amp-Update-Script"><a href="#Install-amp-Update-Script" class="headerlink" title="Install &amp; Update Script"></a>Install &amp; Update Script</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br><span class="line">或</span><br><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm -v</span><br><span class="line"></span><br><span class="line">nvm list</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果报错：</p><p>curl: (7) Failed to connect to raw.githubusercontent.com port 443 after 3 ms: Connection refused</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原因是发现是 github 的一些域名的 DNS 解析被污染，导致DNS 解析过程无法通过域名取得正确的IP地址</span><br><span class="line">解决方案</span><br><span class="line">打开 https://www.ipaddress.com/ 输入访问不了的域名</span><br><span class="line">查询之后可以获得正确的 IP 地址（任意一个即可）</span><br><span class="line">在本机的 host 文件中添加 ，可以使用switchhosts软件管理host</span><br><span class="line">185.199.108.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><p>如果报错 zsh: command not found: nvm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Troubleshooting on Linux</span><br><span class="line"></span><br><span class="line">On Linux, after running the install script, if you get nvm: command not found or see no feedback from your terminal after you type command -v nvm, simply close your current terminal, open a new terminal, and try verifying again. Alternatively, you can run the following commands for the different shells on the command line:</span><br><span class="line"></span><br><span class="line">bash: source ~/.bashrc</span><br><span class="line"></span><br><span class="line">zsh: source ~/.zshrc</span><br><span class="line"></span><br><span class="line">ksh: . ~/.profile</span><br><span class="line"></span><br><span class="line">These should pick up the nvm command.</span><br></pre></td></tr></table></figure><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><h3 id="nvm管理nodejs版本"><a href="#nvm管理nodejs版本" class="headerlink" title="nvm管理nodejs版本"></a>nvm管理nodejs版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最新的lts版本</span> </span><br><span class="line">nvm install --lts </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本号下载(v要不要都可以)</span> </span><br><span class="line">nvm install v10.16.3</span><br></pre></td></tr></table></figure><h3 id="切换node版本："><a href="#切换node版本：" class="headerlink" title="切换node版本："></a>切换node版本：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">macOS系统的use指令只是临时切换</span> </span><br><span class="line">nvm alias default v10.16.3 </span><br></pre></td></tr></table></figure><h3 id="配置淘宝镜像："><a href="#配置淘宝镜像：" class="headerlink" title="配置淘宝镜像："></a>配置淘宝镜像：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global  </span><br><span class="line"></span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure><h3 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm -v </span><br><span class="line">npx -v </span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><h2 id="nvm常用命令"><a href="#nvm常用命令" class="headerlink" title="nvm常用命令"></a>nvm常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nvm install --lts # 下载最新的稳定版 </span><br><span class="line">nvm use &lt;版本号&gt; # 临时切换版本 </span><br><span class="line">nvm alias default &lt;版本号&gt; #永久切换版本（版本别名，default就是默认使用的版本） </span><br><span class="line">nvm uninstall &lt;版本号&gt; # 删除指定版本 </span><br><span class="line">nvm ls # 查看本地所有版本 </span><br><span class="line">nvm ls-remote --lts # 查看线上所有稳定版 </span><br></pre></td></tr></table></figure><h2 id="node常用命令"><a href="#node常用命令" class="headerlink" title="node常用命令"></a>node常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm init # 初始化node环境，-y可以快速初始化 </span><br><span class="line">npm i &lt;package&gt; # 下载指定库，看情况添加 -S或者-D，全局安装-g </span><br><span class="line">npm uninstall &lt;package&gt; # 删除node包，删除全局-g </span><br><span class="line">npm list --depth 0 # 查看当前目录下载的node包 </span><br><span class="line">npm list -g --depth 0 # 查看全局安装的node包</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
